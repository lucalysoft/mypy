-- Checks for incremental mode (see testcheck.py).
-- Each test is run twice, once with a cold cache, once with a warm cache.
-- Before the tests are run the second time, any *.py.next files are copied to *.py.
--
-- Errors expected in the first run should be in the `[out1]` section, and
-- errors expected in the second run should be in the `[out2]` section. If a
-- section is omitted, it is expected there are no errors on that run.
--
-- Any files that we expect to be rechecked should be annotated in the [rechecked]
-- annotation, and any files expect to be stale (aka have a modified interface)
-- should be annotated in the [stale] annotation. Note that a file that ends up
-- producing an error does not create a new cache file and so is not considered stale.
--
-- The test suite will automatically assume that __main__ is stale and rechecked in
-- all cases so we can avoid constantly having to annotate it. The list of
-- rechecked/stale files can be in any arbitrary order, or can be left empty
-- if no files should be rechecked/stale.

[case testIncrementalEmpty]
[rechecked]
[stale]

[case testIncrementalBasics]
import m
[file m.py]
def foo():
    pass
[file m.py.next]
def foo() -> None:
    pass
[rechecked m]
[stale m]

[case testIncrementalError]
import m
[file m.py]
def foo() -> None:
    pass
[file m.py.next]
def foo() -> None:
    bar()
[rechecked m]
[stale]
[out2]
main:1: note: In module imported here:
tmp/m.py: note: In function "foo":
tmp/m.py:2: error: Name 'bar' is not defined

[case testIncrementalSimpleImportSequence]
import mod1
mod1.func1()

[file mod1.py]
import mod2
def func1() -> None: mod2.func2()

[file mod2.py]
import mod3
def func2() -> None: mod3.func3()

[file mod3.py]
def func3() -> None: pass

[rechecked]
[stale]


[case testIncrementalInternalChangeOnly]
import mod1
mod1.func1()

[file mod1.py]
import mod2
def func1() -> None: mod2.func2()

[file mod2.py]
import mod3
def func2() -> None: mod3.func3()

[file mod3.py]
def func3() -> None: pass

[file mod3.py.next]
def func3() -> None: 3 + 2

[rechecked mod3]
[stale]


[case testIncrementalImportGone]
import mod1

[file mod1.py]
from mod2 import A
def func1() -> A: pass

[file mod2.py]
class A: pass

[file mod1.py.next]
def func1() -> A: pass

[rechecked mod1]
[stale]
[out2]
main:1: note: In module imported here:
tmp/mod1.py: note: In function "func1":
tmp/mod1.py:1: error: Name 'A' is not defined

[case testIncrementalSameNameChange]
import mod1

[file mod1.py]
from mod2 import A
def func1() -> A: pass

[file mod2.py]
class A: pass

[file mod2.py.next]
class Parent: pass
class A(Parent): pass

[rechecked mod1, mod2]
[stale mod1, mod2]


[case testIncrementalPartialInterfaceChange]
import mod1
mod1.func1()

[file mod1.py]
import mod2
def func1() -> None: mod2.func2()

[file mod2.py]
import mod3
def func2() -> None: mod3.func3()

[file mod3.py]
def func3() -> None: pass

[file mod3.py.next]
def func3() -> int: return 2

[rechecked mod1, mod2, mod3]
[stale mod1, mod2, mod3]

[case testIncrementalInternalFunctionDefinitionChange]
import mod1

[file mod1.py]
import mod2
def accepts_int(a: int) -> int: return a
accepts_int(mod2.foo())

[file mod2.py]
def foo() -> int:
    def inner() -> int:
        return 42
    return inner()

[file mod2.py.next]
def foo() -> int:
    def inner2() -> str:
        return "foo"
    return inner2()

[rechecked mod2]
[stale]
[out2]
tmp/mod1.py:1: note: In module imported here,
main:1: note: ... from here:
tmp/mod2.py: note: In function "foo":
tmp/mod2.py:4: error: Incompatible return value type (got "str", expected "int")

[case testIncrementalInternalScramble]
import mod1

[file mod1.py]
import mod2
mod2.foo()

[file mod2.py]
def baz() -> int:
    return 3

def bar() -> int:
    return baz()

def foo() -> int:
    return bar()

[file mod2.py.next]
def foo() -> int:
    return baz()

def bar() -> int:
    return bar()

def baz() -> int:
    return 42
[rechecked mod2]
[stale]

[case testIncrementalMethodInterfaceChange]
import mod1

[file mod1.py]
import mod2

[file mod2.py]
class Foo:
    def bar(self, a: str) -> str:
        return "a"

[file mod2.py.next]
class Foo:
    def bar(self, a: float) -> str:
        return "a"

[rechecked mod1, mod2]
[stale mod1, mod2]

[case testIncrementalBaseClassChange]
import mod1

[file mod1.py]
from mod2 import Child
Child().good_method()

[file mod2.py]
class Good:
    def good_method(self) -> int: return 1
class Bad: pass
class Child(Good): pass

[file mod2.py.next]
class Good:
    def good_method(self) -> int: return 1
class Bad: pass
class Child(Bad): pass

[rechecked mod1, mod2]
[stale mod1, mod2]
[out2]
main:1: note: In module imported here:
tmp/mod1.py:2: error: "Child" has no attribute "good_method"

[case testIncrementalCascadingChange]
import mod1

[file mod1.py]
from mod2 import A
def accepts_int(a: int) -> None: pass
accepts_int(A)

[file mod2.py]
from mod3 import B
A = B

[file mod3.py]
from mod4 import C
B = C

[file mod4.py]
C = 3

[file mod4.py.next]
C = "A"

[rechecked mod1, mod2, mod3, mod4]
[stale mod1, mod2, mod3, mod4]
[out2]
main:1: note: In module imported here:
tmp/mod1.py:3: error: Argument 1 to "accepts_int" has incompatible type "str"; expected "int"

[case testIncrementalBrokenCascade]
import mod1

[file mod1.py]
import mod2
def accept_int(a: int) -> int: return a
accept_int(mod2.mod3.mod4.const)

[file mod2.py]
import mod3

[file mod3.py]
import mod4

[file mod4.py]
const = 3

[file mod3.py.next]
# Import to mod4 is gone!

[rechecked mod1, mod2, mod3]
[stale mod1, mod2, mod3]
[builtins fixtures/module.pyi]
[out2]
main:1: note: In module imported here:
tmp/mod1.py:3: error: "module" has no attribute "mod4"

[case testIncrementalRemoteChange]
import mod1

[file mod1.py]
import mod2
def accepts_int(a: int) -> None: pass
accepts_int(mod2.mod3.mod4.const)

[file mod2.py]
import mod3

[file mod3.py]
import mod4

[file mod4.py]
const = 3

[file mod4.py.next]
const = "foo"

[stale mod1, mod2, mod3, mod4]
[out2]
main:1: note: In module imported here:
tmp/mod1.py:3: error: Argument 1 to "accepts_int" has incompatible type "str"; expected "int"

[case testIncrementalBadChange]
import mod1

[file mod1.py]
from mod2 import func2

def func1() -> int:
    return func2()

[file mod2.py]
def func2() -> int:
    return 1

[file mod2.py.next]
def func2() -> str:
    return "foo"

[rechecked mod1, mod2]
[stale mod1, mod2]
[out2]
main:1: note: In module imported here:
tmp/mod1.py: note: In function "func1":
tmp/mod1.py:4: error: Incompatible return value type (got "str", expected "int")

[case testIncrementalWithComplexDictExpression]
import mod1 

[file mod1.py]
import mod1_private

[file mod1_private.py]
my_dict = {
    'a': [1, 2, 3],
    'b': [4, 5, 6]
}

[file mod1_private.py.next]
my_dict = {
    'a': [1, 2, 3],
    'b': [4, 5, 'a']
}

[rechecked mod1, mod1_private]
[stale mod1, mod1_private]
[builtins fixtures/dict.pyi]

[case testIncrementalWithComplexConstantExpressionNoAnnotation]
import mod1 

[file mod1.py]
import mod1_private

[file mod1_private.py]
def foobar() -> int: return 1
def baz() -> int: return 2
const = 1 + foobar()

[file mod1_private.py.next]
def foobar() -> int: return 1
def baz() -> int: return 2
const = 1 + baz()

[rechecked mod1_private]
[stale]

[case testIncrementalWithComplexConstantExpressionWithAnnotation]
import mod1

[file mod1.py]
import mod1_private

[file mod1_private.py]
def foobar() -> int: return 1
def baz() -> int: return 2
const = 1 + foobar()  # type: int

[file mod1_private.py.next]
def foobar() -> int: return 1
def baz() -> int: return 2
const = 1 + baz()  # type: int

[rechecked mod1_private]
[stale]

[case testIncrementalSmall]
import mod1

[file mod1.py]
import mod1_private
def accepts_int(a: int) -> None: pass
accepts_int(mod1_private.some_func(12))

[file mod1_private.py]
def some_func(a: int) -> int:
    return 1

[file mod1_private.py.next]
def some_func(a: int) -> str:
    return "a"

[rechecked mod1, mod1_private]
[stale mod1, mod1_private]
[builtins fixtures/ops.pyi]
[out2]
main:1: note: In module imported here:
tmp/mod1.py:3: error: Argument 1 to "accepts_int" has incompatible type "str"; expected "int"

[case testIncrementalWithDecorators]
import mod1

[file mod1.py]
import mod1_private
def accepts_int(a: int) -> None: pass
accepts_int(mod1_private.some_func(12))

[file mod1_private.py]
from typing import Callable
def multiply(f: Callable[[int], int]) -> Callable[[int], int]:
    return lambda a: f(a) * 10

def stringify(f: Callable[[int], int]) -> Callable[[int], str]:
    return lambda a: str(f(a))

@multiply
def some_func(a: int) -> int:
    return a + 2

[file mod1_private.py.next]
from typing import Callable
def multiply(f: Callable[[int], int]) -> Callable[[int], int]:
    return lambda a: f(a) * 10

def stringify(f: Callable[[int], int]) -> Callable[[int], str]:
    return lambda a: str(f(a))

@stringify
def some_func(a: int) -> int:
    return a + 2
[rechecked mod1, mod1_private]
[stale mod1, mod1_private]
[builtins fixtures/ops.pyi]
[out2]
main:1: note: In module imported here:
tmp/mod1.py:3: error: Argument 1 to "accepts_int" has incompatible type "str"; expected "int"

[case testIncrementalChangingClassAttributes]
import mod1

[file mod1.py]
import mod2
mod2.Foo.A

[file mod2.py]
class Foo:
    A = 3

[file mod2.py.next]
class Foo:
    A = "hello"

[rechecked mod1, mod2]
[stale mod1, mod2]

[case testIncrementalChangingFields]
import mod1

[file mod1.py]
import mod2
f = mod2.Foo()
f.A

[file mod2.py]
class Foo:
    def __init__(self) -> None:
        self.A = 3

[file mod2.py.next]
class Foo:
    def __init__(self) -> None:
        self.A = "hello"

[rechecked mod1, mod2]
[stale mod1, mod2]

[case testIncrementalCheckingChangingFields]
import mod1

[file mod1.py]
import mod2
def accept_int(a: int) -> int: return a
f = mod2.Foo()
accept_int(f.A)

[file mod2.py]
class Foo:
    def __init__(self) -> None:
        self.A = 3

[file mod2.py.next]
class Foo:
    def __init__(self) -> None:
        self.A = "hello"

[rechecked mod1, mod2]
[stale mod1, mod2]
[out2]
main:1: note: In module imported here:
tmp/mod1.py:4: error: Argument 1 to "accept_int" has incompatible type "str"; expected "int"

[case testIncrementalNestedClassDefinition]
import mod1

[file mod1.py]
import mod2
b = mod2.Foo.Bar()
b.attr

[file mod2.py]
class Foo:
    class Bar:
        attr = 3

[file mod2.py.next]
class Foo:
    class Bar:
        attr = "foo"

[rechecked mod1, mod2]
[stale mod1, mod2]

[case testIncrementalSimpleBranchingModules]
import mod1
import mod2

[file mod1.py]
def func() -> None: pass

[file mod2.py]
def func() -> None: pass

[file mod1.py.next]
def func() -> int: return 1

[rechecked mod1]
[stale mod1]

[case testIncrementalSubmoduleImport]
from parent.childA import Foo

def func1() -> Foo:
    return Foo()

[file parent/__init__.py]
from parent.childA import Foo
from parent.childB import Bar

__all__ = ['Foo', 'Bar']

[file parent/childA.py]
import parent

class Foo:
    def test(self) -> int:
        return parent.Bar().test()

[file parent/childB.py]
class Bar:
    def test(self) -> int: return 3

[builtins fixtures/module_all.pyi]
[rechecked]
[stale]

[case testIncrementalSubmoduleParentBackreference]
import parent

[file parent/__init__.py]
from parent import a

[file parent/a.py]
import parent.b

[file parent/b.py]

[builtins fixtures/args.pyi]
[stale]

[case testIncrementalSubmoduleParentBackreferenceComplex]
import parent

[file parent/__init__.py]
import parent.a

[file parent/a.py]
import parent.b
import parent.c

[file parent/b.py]
import parent.a

[file parent/c.py]
import parent.a

[builtins fixtures/args.pyi]
[stale]

[case testIncrementalReferenceNewFileWithImportFrom]
from parent import a

[file parent/__init__.py]

[file parent/a.py]

[file parent/a.py.next]
from parent import b

[file parent/b.py.next]

[stale parent, parent.a, parent.b]

[case testIncrementalReferenceExistingFileWithImportFrom]
from parent import a, b

[file parent/__init__.py]

[file parent/a.py]

[file parent/b.py]

[file parent/a.py.next]
from parent import b

[stale parent.a]

[case testIncrementalWithTypeIgnoreOnDirectImport]
import a, b

[file a.py]
import b  # type: ignore

[file b.py]
import c

[file c.py]

[stale]

[case testIncrementalWithTypeIgnoreOnImportFrom]
import a, b

[file a.py]
from b import something # type: ignore

[file b.py]
import c
something = 3

[file c.py]

[stale]

[case testIncrementalWithPartialTypeIgnore]
import a  # type: ignore
import a.b

[file a/__init__.py]

[file a/b.py]

[stale]

[case testIncrementalAnyIsDifferentFromIgnore]
import b

[file b.py]
from typing import Any
import a.b

[file b.py.next]
from typing import Any

a = 3  # type: Any
import a.b

[file a/__init__.py]

[file a/b.py]

[rechecked b]
[stale]
[out2]
main:1: note: In module imported here:
tmp/b.py:4: error: Name 'a' already defined

[case testIncrementalSilentImportsAndImportsInClass]
# flags: --silent-imports
class MyObject(object):
    from bar import FooBar
[stale]

[case testIncrementalSameFileSize]
import m

[file m.py]
def foo(a: int) -> None: pass
def bar(a: str) -> None: pass

foo(3)

[file m.py.next]
def foo(a: int) -> None: pass
def bar(a: str) -> None: pass

bar(3)

[rechecked m]
[stale]
[out2]
main:1: note: In module imported here:
tmp/m.py:4: error: Argument 1 to "bar" has incompatible type "int"; expected "str"

[case testIncrementalUnsilencingModule]
# cmd: mypy -m main package.subpackage.mod2
# cmd2: mypy -m main package.subpackage.mod1
# flags: --silent-imports

[file main.py]
from package.subpackage.mod1 import Class

def handle(c: Class) -> None:
    c.some_attribute

[file package/__init__.py]
# empty

[file package/subpackage/__init__.py]
# empty

[file package/subpackage/mod1.py]
import collections # Any previously unloaded package works here

class Class: pass

[file package/subpackage/mod2.py]
# empty

[builtins fixtures/args.pyi]
[rechecked collections, main, package.subpackage.mod1]
[stale collections, main, package.subpackage.mod1]
[out2]
tmp/main.py: note: In function "handle":
tmp/main.py:4: error: "Class" has no attribute "some_attribute"

[case testIncrementalWithIgnores]
import foo # type: ignore

[stale]

[case testIncrementalWithSilentImportsAndIgnore]
# cmd: mypy -m main b
# cmd2: mypy -m main c c.submodule
# flags: --silent-imports

[file main.py]
import a  # type: ignore
import b
import c

a.A().foo()
b.B().foo()
c.C().foo()

[file b.py]
class B:
    def foo(self) -> None: pass

[file b.py.next]

[file c/__init__.py]
class C: pass

[file c/submodule.py]
val = 3  # type: int
val = "foo"

[builtins fixtures/module_all.pyi]
[rechecked main, c, c.submodule]
[stale]
[out2]
tmp/c/submodule.py:2: error: Incompatible types in assignment (expression has type "str", variable has type "int")
tmp/main.py:7: error: "C" has no attribute "foo"

[case testIncrementalRemoteError]
import m
m.C().foo().bar()
[file m.py]
import n
class C:
  def foo(self) -> n.A: pass
[file n.py]
class A:
  def bar(self): pass
[file n.py.next]
class A:
  pass
[rechecked m, n]
[stale m, n]
[out2]
main:2: error: "A" has no attribute "bar"

[case testIncrementalRemoteErrorFixed]
import m
m.C().foo().bar()
[file m.py]
import n
class C:
  def foo(self) -> n.A: pass
[file n.py]
class A:
  pass
[file n.py.next]
class A:
  def bar(self): pass
[rechecked m, n]
[stale m, n]
[out1]
main:2: error: "A" has no attribute "bar"

[case testIncrementalChangedError]
import m
[file m.py]
import n
def accept_int(x: int) -> None: pass
accept_int(n.foo)
[file n.py]
foo = "hello"
reveal_type(foo)
[file n.py.next]
foo = 3.14
reveal_type(foo)
[rechecked m, n]
[stale]
[out1]
tmp/m.py:1: note: In module imported here,
main:1: note: ... from here:
tmp/n.py:2: error: Revealed type is 'builtins.str'
main:1: note: In module imported here:
tmp/m.py:3: error: Argument 1 to "accept_int" has incompatible type "str"; expected "int"
[out2]
tmp/m.py:1: note: In module imported here,
main:1: note: ... from here:
tmp/n.py:2: error: Revealed type is 'builtins.float'
main:1: note: In module imported here:
tmp/m.py:3: error: Argument 1 to "accept_int" has incompatible type "float"; expected "int"

[case testIncrementalReplacingImports]
import good, bad, client

[file good.py]
def foo(a: int) -> None: pass

[file bad.py]
def foo(a: str) -> None: pass

[file client.py]
import good
import bad 
from good import foo
foo(3)

[file client.py.next]
import good
import bad
from bad import foo
foo(3)

[rechecked client]
[stale]
[out2]
main:1: note: In module imported here:
tmp/client.py:4: error: Argument 1 to "foo" has incompatible type "int"; expected "str"
