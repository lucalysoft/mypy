[case testTrivialFunction]
def f() -> int:
    return 1
[out]
def f():
    r0 :: int
L0:
    r0 = 1
    return r0

[case testFunctionArgument]
def f(x: int) -> int:
    return x
[out]
def f(x):
    x :: int
L0:
    return x

[case testExplicitNoneReturn]
def f() -> None:
    return
[out]
def f():
    r0 :: None
L0:
    r0 = None
    return r0

[case testExplicitNoneReturn2]
def f() -> None:
    return None
[out]
def f():
    r0 :: None
L0:
    r0 = None
    return r0

[case testAssignment]
def f() -> int:
    x = 1
    y = x
    return y
[out]
def f():
    x, r0, y :: int
L0:
    r0 = 1
    x = r0
    y = x
    return y

[case testAssignmentTwice]
def f(x: int) -> None:
    y = 1
    y = x
    return
[out]
def f(x):
    x, y, r0 :: int
    r1 :: None
L0:
    r0 = 1
    y = r0
    y = x
    r1 = None
    return r1

[case testIntArithmetic]
def f(x: int, y: int) -> int:
    return x * (y + 1)
[out]
def f(x, y):
    x, y, r0, r1, r2 :: int
L0:
    r0 = 1
    r1 = y + r0 :: int
    r2 = x * r1 :: int
    return r2

[case testIf]
def f(x: int, y: int) -> int:
    if x < y:
        x = 1
    return x
[out]
def f(x, y):
    x, y :: int
    r0 :: bool
    r1 :: int
L0:
    r0 = x < y :: int
    if r0 goto L1 else goto L2 :: bool
L1:
    r1 = 1
    x = r1
L2:
    return x

[case testIfElse]
def f(x: int, y: int) -> int:
    if x < y:
        x = 1
    else:
        x = 2
    return x
[out]
def f(x, y):
    x, y :: int
    r0 :: bool
    r1, r2 :: int
L0:
    r0 = x < y :: int
    if r0 goto L1 else goto L2 :: bool
L1:
    r1 = 1
    x = r1
    goto L3
L2:
    r2 = 2
    x = r2
L3:
    return x

[case testAnd1]
def f(x: int, y: int) -> int:
    if x < y and x > y:
        x = 1
    else:
        x = 2
    return x
[out]
def f(x, y):
    x, y :: int
    r0, r1 :: bool
    r2, r3 :: int
L0:
    r0 = x < y :: int
    if r0 goto L1 else goto L3 :: bool
L1:
    r1 = x > y :: int
    if r1 goto L2 else goto L3 :: bool
L2:
    r2 = 1
    x = r2
    goto L4
L3:
    r3 = 2
    x = r3
L4:
    return x

[case testAnd2]
def f(x: object, y: object) -> str:
    return str(x) or str(y)
[out]
def f(x, y):
    x, y :: object
    r0, r1 :: str
    r2 :: bool
    r3 :: str
L0:
    r1 = str x :: object
    r2 = bool r1 :: object
    if r2 goto L1 else goto L2 :: bool
L1:
    r0 = r1
    goto L3
L2:
    r3 = str y :: object
    r0 = r3
L3:
    return r0

[case testOr]
def f(x: int, y: int) -> int:
    if x < y or x > y:
        x = 1
    else:
        x = 2
    return x
[out]
def f(x, y):
    x, y :: int
    r0, r1 :: bool
    r2, r3 :: int
L0:
    r0 = x < y :: int
    if r0 goto L2 else goto L1 :: bool
L1:
    r1 = x > y :: int
    if r1 goto L2 else goto L3 :: bool
L2:
    r2 = 1
    x = r2
    goto L4
L3:
    r3 = 2
    x = r3
L4:
    return x

[case testOr2]
def f(x: object, y: object) -> str:
    return str(x) and str(y)
[out]
def f(x, y):
    x, y :: object
    r0, r1 :: str
    r2 :: bool
    r3 :: str
L0:
    r1 = str x :: object
    r2 = bool r1 :: object
    if r2 goto L2 else goto L1 :: bool
L1:
    r0 = r1
    goto L3
L2:
    r3 = str y :: object
    r0 = r3
L3:
    return r0

[case testSimpleNot]
def f(x: int, y: int) -> int:
    if not (x < y):
        x = 1
    return x
[out]
def f(x, y):
    x, y :: int
    r0 :: bool
    r1 :: int
L0:
    r0 = x < y :: int
    if r0 goto L2 else goto L1 :: bool
L1:
    r1 = 1
    x = r1
L2:
    return x

[case testNotAnd]
def f(x: int, y: int) -> int:
    if not (x < y and x > y):
        x = 1
    return x
[out]
def f(x, y):
    x, y :: int
    r0, r1 :: bool
    r2 :: int
L0:
    r0 = x < y :: int
    if r0 goto L1 else goto L2 :: bool
L1:
    r1 = x > y :: int
    if r1 goto L3 else goto L2 :: bool
L2:
    r2 = 1
    x = r2
L3:
    return x

[case testWhile]
def f(x: int, y: int) -> int:
    while x > y:
        x = x - y
    return x
[out]
def f(x, y):
    x, y :: int
    r0 :: bool
    r1 :: int
L0:
L1:
    r0 = x > y :: int
    if r0 goto L2 else goto L3 :: bool
L2:
    r1 = x - y :: int
    x = r1
    goto L1
L3:
    return x

[case testWhile2]
def f(x: int, y: int) -> int:
    x = 1
    while x > y:
        x = x - y
    return x
[out]
def f(x, y):
    x, y, r0 :: int
    r1 :: bool
    r2 :: int
L0:
    r0 = 1
    x = r0
L1:
    r1 = x > y :: int
    if r1 goto L2 else goto L3 :: bool
L2:
    r2 = x - y :: int
    x = r2
    goto L1
L3:
    return x

[case testImplicitNoneReturn]
def f() -> None:
    pass
[out]
def f():
    r0 :: None
L0:
    r0 = None
    return r0

[case testImplicitNoneReturn2]
def f() -> None:
    x = 1
[out]
def f():
    x, r0 :: int
    r1 :: None
L0:
    r0 = 1
    x = r0
    r1 = None
    return r1

[case testImplicitNoneReturnAndIf]
def f(x: int, y: int) -> None:
    if x < y:
        x = 1
    else:
        y = 2
[out]
def f(x, y):
    x, y :: int
    r0 :: bool
    r1, r2 :: int
    r3 :: None
L0:
    r0 = x < y :: int
    if r0 goto L1 else goto L2 :: bool
L1:
    r1 = 1
    x = r1
    goto L3
L2:
    r2 = 2
    y = r2
L3:
    r3 = None
    return r3

[case testRecursion]
def f(n: int) -> int:
    if n <= 1:
        return 1
    else:
        return f(n - 1) + f(n - 2)
[out]
def f(n):
    n, r0 :: int
    r1 :: bool
    r2, r3, r4, r5, r6, r7, r8, r9 :: int
L0:
    r0 = 1
    r1 = n <= r0 :: int
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = 1
    return r2
L2:
    r3 = 1
    r4 = n - r3 :: int
    r5 = f(r4)
    r6 = 2
    r7 = n - r6 :: int
    r8 = f(r7)
    r9 = r5 + r8 :: int
    return r9
L3:
    unreachable

[case testReportTypeCheckError]
def f() -> None:
    return 1 # E: No return value expected

[case testReportSemanticaAnalysisError1]
def f(x: List[int]) -> None: pass # E: Name 'List' is not defined

[case testReportSemanticaAnalysisError2]
def f() -> None:
    x # E: Name 'x' is not defined

[case testElif]
def f(n: int) -> int:
    if n < 0:
        x = 1
    elif n == 0:
        x = 1
    else:
        x = 2
    return x
[out]
def f(n):
    n, r0 :: int
    r1 :: bool
    x, r2, r3 :: int
    r4 :: bool
    r5, r6 :: int
L0:
    r0 = 0
    r1 = n < r0 :: int
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = 1
    x = r2
    goto L6
L2:
    r3 = 0
    r4 = n == r3 :: int
    if r4 goto L3 else goto L4 :: bool
L3:
    r5 = 1
    x = r5
    goto L5
L4:
    r6 = 2
    x = r6
L5:
L6:
    return x

[case testUnaryMinus]
def f(n: int) -> int:
    return -1
[out]
def f(n):
    n, r0, r1 :: int
L0:
    r0 = 1
    r1 = -r0 :: int
    return r1

[case testConditionalExpr]
def f(n: int) -> int:
    return 0 if n == 0 else 1
[out]
def f(n):
    n, r0 :: int
    r1 :: bool
    r2, r3, r4 :: int
L0:
    r0 = 0
    r1 = n == r0 :: int
    if r1 goto L1 else goto L2 :: bool
L1:
    r3 = 0
    r2 = r3
    goto L3
L2:
    r4 = 1
    r2 = r4
L3:
    return r2

[case testOperatorAssignment]
def f() -> int:
    x = 0
    x += 1
    return x
[out]
def f():
    x, r0, r1, r2 :: int
L0:
    r0 = 0
    x = r0
    r1 = 1
    r2 = x + r1 :: int
    x = r2
    return x

[case testTrue]
def f() -> bool:
    return True
[out]
def f():
    r0 :: bool
L0:
    r0 = True
    return r0

[case testFalse]
def f() -> bool:
    return False
[out]
def f():
    r0 :: bool
L0:
    r0 = False
    return r0

[case testBoolCond]
def f(x: bool) -> bool:
    if x:
        return False
    else:
        return True
[out]
def f(x):
    x, r0, r1 :: bool
L0:
    if x goto L1 else goto L2 :: bool
L1:
    r0 = False
    return r0
L2:
    r1 = True
    return r1
L3:
    unreachable

[case testPycall]
import testmodule

def f(x: int) -> int:
    return testmodule.factorial(x)
[file testmodule.py]
def factorial(x: int) -> int:
    if x == 0:
        return 1
    else:
        return x * factorial(x-1)
[out]
def f(x):
    x :: int
    r0 :: object
    r1 :: str
    r2, r3, r4 :: object
    r5 :: int
L0:
    r0 = testmodule.module :: static
    r1 = unicode_0 :: static  ('factorial')
    r2 = getattr r0, r1
    r3 = box(int, x)
    r4 = py_call(r2, r3)
    r5 = unbox(int, r4)
    return r5

[case testFromImport]
from testmodule import g

def f(x: int) -> int:
    return g(x)
[file testmodule.py]
def g(x: int) -> int:
    return x + 1
[out]
def f(x):
    x :: int
    r0 :: object
    r1 :: str
    r2, r3, r4 :: object
    r5 :: int
L0:
    r0 = __main__.globals :: static
    r1 = unicode_0 :: static  ('g')
    r2 = r0[r1] :: dict
    r3 = box(int, x)
    r4 = py_call(r2, r3)
    r5 = unbox(int, r4)
    return r5

[case testPrintFullname]
import builtins
def f(x: int) -> None:
    builtins.print(5)
[out]
def f(x):
    x :: int
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: int
    r4, r5 :: object
    r6, r7 :: None
L0:
    r0 = builtins.module :: static
    r1 = unicode_0 :: static  ('print')
    r2 = getattr r0, r1
    r3 = 5
    r4 = box(int, r3)
    r5 = py_call(r2, r4)
    r6 = cast(None, r5)
    r7 = None
    return r7

[case testPrint]
import builtins
def f(x: int) -> None:
    print(5)
[out]
def f(x):
    x, r0 :: int
    r1 :: object
    r2 :: str
    r3, r4, r5 :: object
    r6, r7 :: None
L0:
    r0 = 5
    r1 = builtins.module :: static
    r2 = unicode_0 :: static  ('print')
    r3 = getattr r1, r2
    r4 = box(int, r0)
    r5 = py_call(r3, r4)
    r6 = cast(None, r5)
    r7 = None
    return r7

[case testUnicodeLiteral]
def f() -> str:
    x = "some string"
    return "some other string"
[out]
def f():
    x, r0, r1 :: str
L0:
    r0 = unicode_0 :: static  ('some string')
    x = r0
    r1 = unicode_1 :: static  ('some other string')
    return r1

[case testPyMethodCall1]
from typing import List
def f(x: List[int]) -> int:
    y = x.pop()
    return x.pop()
[out]
def f(x):
    x :: list
    y :: int
    r0 :: str
    r1 :: object
    r2 :: int
    r3 :: str
    r4 :: object
    r5 :: int
L0:
    r0 = unicode_0 :: static  ('pop')
    r1 = py_method_call(x, r0)
    r2 = unbox(int, r1)
    y = r2
    r3 = unicode_0 :: static  ('pop')
    r4 = py_method_call(x, r3)
    r5 = unbox(int, r4)
    return r5

[case testObjectType]
def g(y: object) -> None:
    g(y)
    g([1])
    g(None)
[out]
def g(y):
    y :: object
    r0 :: None
    r1 :: int
    r2 :: object
    r3 :: list
    r4, r5, r6, r7 :: None
L0:
    r0 = g(y)
    r1 = 1
    r2 = box(int, r1)
    r3 = [r2]
    r4 = g(r3)
    r5 = None
    r6 = g(r5)
    r7 = None
    return r7

[case testCoerceToObject1]
def g(y: object) -> object:
    g(1)
    a = [y]
    a[0] = (1, 2)
    y = True
    return 3
[out]
def g(y):
    y :: object
    r0 :: int
    r1, r2 :: object
    a, r3 :: list
    r4, r5, r6 :: int
    r7 :: tuple[int, int]
    r8 :: object
    r9, r10 :: bool
    r11 :: object
    r12 :: int
    r13 :: object
L0:
    r0 = 1
    r1 = box(int, r0)
    r2 = g(r1)
    r3 = [y]
    a = r3
    r4 = 0
    r5 = 1
    r6 = 2
    r7 = (r5, r6)
    r8 = box(tuple[int, int], r7)
    r9 = a.__setitem__(r4, r8) :: list
    r10 = True
    r11 = box(bool, r10)
    y = r11
    r12 = 3
    r13 = box(int, r12)
    return r13

[case testCoerceToObject2]
class A:
    x: object
    n: int
def f(a: A, o: object) -> None:
    a.x = 1
    o = a.n
[out]
def f(a, o):
    a :: A
    o :: object
    r0 :: int
    r1 :: object
    r2 :: bool
    r3 :: int
    r4 :: object
    r5 :: None
L0:
    r0 = 1
    r1 = box(int, r0)
    a.x = r1; r2 = is_error
    r3 = a.n
    r4 = box(int, r3)
    o = r4
    r5 = None
    return r5

[case testDownCast]
from typing import cast, List, Tuple
class A: pass
def f(x: object) -> None:
    n = cast(int, x)
    b = cast(bool, x)
    a = cast(A, x)
    l = cast(List[int], x)
    t = cast(Tuple[int, A], x)
[out]
def f(x):
    x :: object
    n, r0 :: int
    b, r1 :: bool
    a, r2 :: A
    l, r3 :: list
    t, r4 :: tuple[int, A]
    r5 :: None
L0:
    r0 = unbox(int, x)
    n = r0
    r1 = unbox(bool, x)
    b = r1
    r2 = cast(A, x)
    a = r2
    r3 = cast(list, x)
    l = r3
    r4 = unbox(tuple[int, A], x)
    t = r4
    r5 = None
    return r5

[case testDownCastSpecialCases]
from typing import cast, Optional, Tuple
class A: pass
def f(o: Optional[A], n: int, t: Tuple[int, ...]) -> None:
    a = cast(A, o)
    m = cast(bool, n)
    tt: Tuple[int, int]
    t = tt
[out]
def f(o, n, t):
    o :: optional[A]
    n :: int
    t :: tuple
    a, r0 :: A
    m :: bool
    r1 :: object
    r2 :: bool
    tt :: tuple[int, int]
    r3 :: object
    r4 :: None
L0:
    r0 = cast(A, o)
    a = r0
    r1 = box(int, n)
    r2 = unbox(bool, r1)
    m = r2
    r3 = box(tuple[int, int], tt)
    t = r3
    r4 = None
    return r4

[case testSuccessfulCast]
from typing import cast, Optional, Tuple, List, Dict
class A: pass
def f(o: object,
      p: Optional[A],
      n: int,
      b: bool,
      t: Tuple[int, ...],
      s: Tuple[int, int],
      a: A,
      l: List[A],
      d: Dict[int, str]) -> None:
    o = cast(object, o)
    p = cast(Optional[A], p)
    n = cast(int, n)
    b = cast(bool, b)
    t = cast(Tuple[int, ...], t)
    s = cast(Tuple[int, int], s)
    o = cast(object, n)
    a = cast(A, a)
    l2 = cast(List[object], l)
    d2 = cast(Dict[object, str], d)
[out]
def f(o, p, n, b, t, s, a, l, d):
    o :: object
    p :: optional[A]
    n :: int
    b :: bool
    t :: tuple
    s :: tuple[int, int]
    a :: A
    l :: list
    d :: dict
    r0 :: object
    l2 :: list
    d2 :: dict
    r1 :: None
L0:
    o = o
    p = p
    n = n
    b = b
    t = t
    s = s
    r0 = box(int, n)
    o = r0
    a = a
    l2 = l
    d2 = d
    r1 = None
    return r1

[case testGenericSetItem]
from typing import Any
def f(x: Any, y: Any, z: Any) -> None:
    x[y] = z
[out]
def f(x, y, z):
    x, y, z :: object
    r0 :: bool
    r1 :: None
L0:
    r0 = x.__setitem__(y, z) :: object
    r1 = None
    return r1

[case testLoadFloatSum]
def assign_and_return_float_sum() -> float:
    f1 = 1.0
    f2 = 2.0
    f3 = 3.0
    return f1 * f2 + f3
[out]
def assign_and_return_float_sum():
    f1, r0, f2, r1, f3, r2 :: float
    r3 :: object
    r4 :: float
    r5 :: object
    r6 :: float
L0:
    r0 = float_0 :: static  (1.0)
    f1 = r0
    r1 = float_1 :: static  (2.0)
    f2 = r1
    r2 = float_2 :: static  (3.0)
    f3 = r2
    r3 = f1 * f2
    r4 = cast(float, r3)
    r5 = r4 + f3
    r6 = cast(float, r5)
    return r6

[case testBigIntLiteral]
def big_int() -> None:
    a_62_bit = 4611686018427387902
    max_62_bit = 4611686018427387903
    b_63_bit = 4611686018427387904
    c_63_bit = 9223372036854775806
    max_63_bit = 9223372036854775807
    d_64_bit = 9223372036854775808
    max_32_bit = 2147483647
[out]
def big_int():
    a_62_bit, r0, max_62_bit, r1, b_63_bit, r2, c_63_bit, r3, max_63_bit, r4, d_64_bit, r5, max_32_bit, r6 :: int
    r7 :: None
L0:
    r0 = 4611686018427387902
    a_62_bit = r0
    r1 = 4611686018427387903
    max_62_bit = r1
    r2 = int_0 :: static  (4611686018427387904)
    b_63_bit = r2
    r3 = int_1 :: static  (9223372036854775806)
    c_63_bit = r3
    r4 = int_2 :: static  (9223372036854775807)
    max_63_bit = r4
    r5 = int_3 :: static  (9223372036854775808)
    d_64_bit = r5
    r6 = 2147483647
    max_32_bit = r6
    r7 = None
    return r7

[case testCallableTypes]
from typing import Callable
def absolute_value(x: int) -> int:
    return x if x > 0 else -x

def call_native_function(x: int) -> int:
    return absolute_value(x)

def call_python_function(x: int) -> int:
    return int(x)

def return_float() -> float:
    return 5.0

def return_callable_type() -> Callable[[], float]:
    return return_float

def call_callable_type() -> float:
    f = return_callable_type()
    return f()
[out]
def absolute_value(x):
    x, r0 :: int
    r1 :: bool
    r2, r3 :: int
L0:
    r0 = 0
    r1 = x > r0 :: int
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = x
    goto L3
L2:
    r3 = -x :: int
    r2 = r3
L3:
    return r2
def call_native_function(x):
    x, r0 :: int
L0:
    r0 = absolute_value(x)
    return r0
def call_python_function(x):
    x :: int
    r0 :: object
    r1 :: str
    r2, r3, r4 :: object
    r5 :: int
L0:
    r0 = builtins.module :: static
    r1 = unicode_0 :: static  ('int')
    r2 = getattr r0, r1
    r3 = box(int, x)
    r4 = py_call(r2, r3)
    r5 = unbox(int, r4)
    return r5
def return_float():
    r0 :: float
L0:
    r0 = float_1 :: static  (5.0)
    return r0
def return_callable_type():
    r0 :: object
    r1 :: str
    r2 :: object
L0:
    r0 = __main__.globals :: static
    r1 = unicode_2 :: static  ('return_float')
    r2 = r0[r1] :: dict
    return r2
def call_callable_type():
    f, r0, r1 :: object
    r2 :: float
L0:
    r0 = return_callable_type()
    f = r0
    r1 = py_call(f)
    r2 = cast(float, r1)
    return r2

[case testNestedFunctions]
from typing import Callable

def a() -> Callable[[], object]:
    def inner() -> object:
        return None
    return inner

def b() -> Callable[[], Callable[[], str]]:
    def first() -> Callable[[], str]:
        def second() -> str:
            return 'b.first.second: nested function'
        return second
    return first

def c(num: float) -> Callable[[str], str]:
    def inner(s: str) -> str:
        return s + '!'
    return inner

def d(num: float) -> str:
    def inner(s: str) -> str:
        return s + '?'
    a = inner('one')
    b = inner('two')
    return a

def inner() -> str:
    return 'inner: normal function'

def first() -> str:
    return 'first: normal function'

def second() -> str:
    return 'second: normal function'
[out]
def inner_a_obj.__call__(self):
    self :: inner_a_obj
    r0 :: None
L0:
    r0 = None
    return r0
def a():
    r0 :: a__env
    r1 :: inner_a_obj
    r2 :: bool
    inner :: object
L0:
    r0 = a__env()
    r1 = inner_a_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    inner = r1
    return inner
def second_b_first_obj.__call__(self):
    self :: second_b_first_obj
    r0 :: str
L0:
    r0 = unicode_0 :: static  ('b.first.second: nested function')
    return r0
def first_b_obj.__call__(self):
    self :: first_b_obj
    r0 :: first_b_env
    r1 :: b__env
    r2 :: bool
    r3 :: second_b_first_obj
    r4 :: bool
    second :: object
L0:
    r0 = first_b_env()
    r1 = self.__mypyc_env__
    r0.__mypyc_env__ = r1; r2 = is_error
    r3 = second_b_first_obj()
    r3.__mypyc_env__ = r0; r4 = is_error
    second = r3
    return second
def b():
    r0 :: b__env
    r1 :: first_b_obj
    r2 :: bool
    first :: object
L0:
    r0 = b__env()
    r1 = first_b_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    first = r1
    return first
def inner_c_obj.__call__(self, s):
    self :: inner_c_obj
    s, r0, r1 :: str
L0:
    r0 = unicode_1 :: static  ('!')
    r1 = s + r0
    return r1
def c(num):
    num :: float
    r0 :: c__env
    r1 :: bool
    r2 :: inner_c_obj
    r3 :: bool
    inner :: object
L0:
    r0 = c__env()
    r0.num = num; r1 = is_error
    r2 = inner_c_obj()
    r2.__mypyc_env__ = r0; r3 = is_error
    inner = r2
    return inner
def inner_d_obj.__call__(self, s):
    self :: inner_d_obj
    s, r0, r1 :: str
L0:
    r0 = unicode_2 :: static  ('?')
    r1 = s + r0
    return r1
def d(num):
    num :: float
    r0 :: d__env
    r1 :: bool
    r2 :: inner_d_obj
    r3 :: bool
    inner :: object
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: bool
    r8 :: str
    r9 :: object
    r10 :: str
    r11 :: bool
    r12 :: str
L0:
    r0 = d__env()
    r0.num = num; r1 = is_error
    r2 = inner_d_obj()
    r2.__mypyc_env__ = r0; r3 = is_error
    inner = r2
    r4 = unicode_3 :: static  ('one')
    r5 = py_call(inner, r4)
    r6 = cast(str, r5)
    r0.a = r6; r7 = is_error
    r8 = unicode_4 :: static  ('two')
    r9 = py_call(inner, r8)
    r10 = cast(str, r9)
    r0.b = r10; r11 = is_error
    r12 = r0.a
    return r12
def inner():
    r0 :: str
L0:
    r0 = unicode_5 :: static  ('inner: normal function')
    return r0
def first():
    r0 :: str
L0:
    r0 = unicode_6 :: static  ('first: normal function')
    return r0
def second():
    r0 :: str
L0:
    r0 = unicode_7 :: static  ('second: normal function')
    return r0

[case testFreeVars]
from typing import Callable

def a(num: int) -> int:
    def inner() -> int:
        return num
    return inner()

def b() -> int:
    num = 3
    def inner() -> int:
        nonlocal num
        num = 4
        foo = 6
        return num
    return inner() + num

def c(flag: bool) -> str:
    if flag:
        def inner() -> str:
            return 'f.inner: first definition'
    else:
        def inner() -> str:
            return 'f.inner: second definition'
    return inner()
    
[out]
def inner_a_obj.__call__(self):
    self :: inner_a_obj
    r0 :: a__env
    r1 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = r0.num
    return r1
def a(num):
    num :: int
    r0 :: a__env
    r1 :: bool
    r2 :: inner_a_obj
    r3 :: bool
    inner, r4 :: object
    r5 :: int
L0:
    r0 = a__env()
    r0.num = num; r1 = is_error
    r2 = inner_a_obj()
    r2.__mypyc_env__ = r0; r3 = is_error
    inner = r2
    r4 = py_call(inner)
    r5 = unbox(int, r4)
    return r5
def inner_b_obj.__call__(self):
    self :: inner_b_obj
    r0 :: b__env
    r1 :: int
    r2 :: bool
    foo, r3 :: int
    r4 :: b__env
    r5 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = 4
    r0.num = r1; r2 = is_error
    r3 = 6
    foo = r3
    r4 = self.__mypyc_env__
    r5 = r4.num
    return r5
def b():
    r0 :: b__env
    r1 :: int
    r2 :: bool
    r3 :: inner_b_obj
    r4 :: bool
    inner, r5 :: object
    r6, r7, r8 :: int
L0:
    r0 = b__env()
    r1 = 3
    r0.num = r1; r2 = is_error
    r3 = inner_b_obj()
    r3.__mypyc_env__ = r0; r4 = is_error
    inner = r3
    r5 = py_call(inner)
    r6 = unbox(int, r5)
    r7 = r0.num
    r8 = r6 + r7 :: int
    return r8
def inner_c_obj.__call__(self):
    self :: inner_c_obj
    r0 :: str
L0:
    r0 = unicode_0 :: static  ('f.inner: first definition')
    return r0
def inner_c_obj_0.__call__(self):
    self :: inner_c_obj_0
    r0 :: str
L0:
    r0 = unicode_1 :: static  ('f.inner: second definition')
    return r0
def c(flag):
    flag :: bool
    r0 :: c__env
    r1, r2 :: bool
    r3 :: inner_c_obj
    r4 :: bool
    inner :: object
    r5 :: inner_c_obj_0
    r6 :: bool
    r7 :: object
    r8 :: str
L0:
    r0 = c__env()
    r0.flag = flag; r1 = is_error
    r2 = r0.flag
    if r2 goto L1 else goto L2 :: bool
L1:
    r3 = inner_c_obj()
    r3.__mypyc_env__ = r0; r4 = is_error
    inner = r3
    goto L3
L2:
    r5 = inner_c_obj_0()
    r5.__mypyc_env__ = r0; r6 = is_error
    inner = r5
L3:
    r7 = py_call(inner)
    r8 = cast(str, r7)
    return r8

[case testSpecialNestedd]
def a() -> int:
    x = 1
    def b() -> int:
        x += 1        
        def c() -> int:
            return x
        return c()
    return b()

[out]
def c_a_b_obj.__call__(self):
    self :: c_a_b_obj
    r0 :: b_a_env
    r1 :: a__env
    r2 :: int
L0:
    r0 = self.__mypyc_env__
    r1 = r0.__mypyc_env__
    r2 = r1.x
    return r2
def b_a_obj.__call__(self):
    self :: b_a_obj
    r0 :: b_a_env
    r1 :: a__env
    r2 :: bool
    r3 :: a__env
    r4, r5, r6 :: int
    r7 :: bool
    r8 :: c_a_b_obj
    r9 :: bool
    c, r10 :: object
    r11 :: int
L0:
    r0 = b_a_env()
    r1 = self.__mypyc_env__
    r0.__mypyc_env__ = r1; r2 = is_error
    r3 = self.__mypyc_env__
    r4 = 1
    r5 = r3.x
    r6 = r5 + r4 :: int
    r3.x = r6; r7 = is_error
    r8 = c_a_b_obj()
    r8.__mypyc_env__ = r0; r9 = is_error
    c = r8
    r10 = py_call(c)
    r11 = unbox(int, r10)
    return r11
def a():
    r0 :: a__env
    r1 :: int
    r2 :: bool
    r3 :: b_a_obj
    r4 :: bool
    b, r5 :: object
    r6 :: int
L0:
    r0 = a__env()
    r1 = 1
    r0.x = r1; r2 = is_error
    r3 = b_a_obj()
    r3.__mypyc_env__ = r0; r4 = is_error
    b = r3
    r5 = py_call(b)
    r6 = unbox(int, r5)
    return r6

[case testNestedFunctionInsideStatements]
def f(flag: bool) -> str:
    if flag:
        def inner() -> str:
            return 'f.inner: first definition'
    else:
        def inner() -> str:
            return 'f.inner: second definition'
    return inner()
[out]
def inner_f_obj.__call__(self):
    self :: inner_f_obj
    r0 :: str
L0:
    r0 = unicode_0 :: static  ('f.inner: first definition')
    return r0
def inner_f_obj_0.__call__(self):
    self :: inner_f_obj_0
    r0 :: str
L0:
    r0 = unicode_1 :: static  ('f.inner: second definition')
    return r0
def f(flag):
    flag :: bool
    r0 :: f__env
    r1, r2 :: bool
    r3 :: inner_f_obj
    r4 :: bool
    inner :: object
    r5 :: inner_f_obj_0
    r6 :: bool
    r7 :: object
    r8 :: str
L0:
    r0 = f__env()
    r0.flag = flag; r1 = is_error
    r2 = r0.flag
    if r2 goto L1 else goto L2 :: bool
L1:
    r3 = inner_f_obj()
    r3.__mypyc_env__ = r0; r4 = is_error
    inner = r3
    goto L3
L2:
    r5 = inner_f_obj_0()
    r5.__mypyc_env__ = r0; r6 = is_error
    inner = r5
L3:
    r7 = py_call(inner)
    r8 = cast(str, r7)
    return r8

[case testObjectAsBoolean]
from typing import List

def obj(x: object) -> int:
    if x:
        return 1
    else:
        return 0

def num(x: int) -> int:
    if x:
        return 1
    else:
        return 0

def lst(x: List[int]) -> int:
    if x:
        return 1
    else:
        return 0
[out]
def obj(x):
    x :: object
    r0 :: bool
    r1, r2 :: int
L0:
    r0 = bool x :: object
    if r0 goto L1 else goto L2 :: bool
L1:
    r1 = 1
    return r1
L2:
    r2 = 0
    return r2
L3:
    unreachable
def num(x):
    x, r0 :: int
    r1 :: bool
    r2, r3 :: int
L0:
    r0 = 0
    r1 = x != r0 :: int
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = 1
    return r2
L2:
    r3 = 0
    return r3
L3:
    unreachable
def lst(x):
    x :: list
    r0, r1 :: int
    r2 :: bool
    r3, r4 :: int
L0:
    r0 = len x :: list
    r1 = 0
    r2 = r0 != r1 :: int
    if r2 goto L1 else goto L2 :: bool
L1:
    r3 = 1
    return r3
L2:
    r4 = 0
    return r4
L3:
    unreachable

[case testOptionalAsBoolean]
from typing import Optional

class A: pass

def opt_int(x: Optional[int]) -> int:
    if x:
        return 1
    else:
        return 0

def opt_a(x: Optional[A]) -> int:
    if x:
        return 1
    else:
        return 0
[out]
def opt_int(x):
    x :: optional[int]
    r0 :: None
    r1 :: bool
    r2, r3 :: int
    r4 :: bool
    r5, r6 :: int
L0:
    r0 = None
    r1 = x is not r0
    if r1 goto L1 else goto L3 :: bool
L1:
    r2 = unbox(int, x)
    r3 = 0
    r4 = r2 != r3 :: int
    if r4 goto L2 else goto L3 :: bool
L2:
    r5 = 1
    return r5
L3:
    r6 = 0
    return r6
L4:
    unreachable
def opt_a(x):
    x :: optional[A]
    r0 :: None
    r1 :: bool
    r2, r3 :: int
L0:
    r0 = None
    r1 = x is not r0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = 1
    return r2
L2:
    r3 = 0
    return r3
L3:
    unreachable

[case testModuleTopLevel]
x = 1
print(x)

def f() -> None:
    print(x)
[out]
def f():
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: int
    r4 :: object
    r5 :: str
    r6, r7, r8 :: object
    r9, r10 :: None
L0:
    r0 = __main__.globals :: static
    r1 = unicode_0 :: static  ('x')
    r2 = r0[r1] :: dict
    r3 = unbox(int, r2)
    r4 = builtins.module :: static
    r5 = unicode_1 :: static  ('print')
    r6 = getattr r4, r5
    r7 = box(int, r3)
    r8 = py_call(r6, r7)
    r9 = cast(None, r8)
    r10 = None
    return r10
def __top_level__():
    r0 :: object
    r1 :: str
    r2 :: int
    r3 :: object
    r4 :: bool
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: int
    r9 :: object
    r10 :: str
    r11, r12, r13 :: object
    r14, r15 :: None
L0:
    r0 = __main__.globals :: static
    r1 = unicode_0 :: static  ('x')
    r2 = 1
    r3 = box(int, r2)
    r4 = r0.__setitem__(r1, r3) :: object
    r5 = __main__.globals :: static
    r6 = unicode_0 :: static  ('x')
    r7 = r5[r6] :: dict
    r8 = unbox(int, r7)
    r9 = builtins.module :: static
    r10 = unicode_1 :: static  ('print')
    r11 = getattr r9, r10
    r12 = box(int, r8)
    r13 = py_call(r11, r12)
    r14 = cast(None, r13)
    r15 = None
    return r15
