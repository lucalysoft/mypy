[case testTree]
from typing import Optional
class Node:
    def __init__(self, value: int) -> None:
        self.value = value
        self.left = None  # type: Optional[Node]
        self.right = None  # type: Optional[Node]
    def sum(self) -> int:
        left = 0
        if self.left is not None:
            left = self.left.sum()
        right = 0
        if self.right is not None:
            right = self.right.sum()
        return self.value + left + right
def sum_tree(x: Optional[Node]) -> int:
    if x is None:
        return 0
    return x.value + sum_tree(x.left) + sum_tree(x.right)
def lol(n: int) -> Optional[Node]:
    if n == 0:
        return None
    x = Node(n)
    x.left = lol(n - 1)
    x.right = x.left
    return x

def bench_sum(x: Optional[Node]) -> None:
    for i in range(1000000):
        sum_tree(x)
def bench_sum_method(x: Node) -> None:
    for i in range(1000000):
        x.sum()
[file driver.py]
from typing import Optional
import native
import interpreted
from timeit import timeit
from time import time

def dumb_time(f):
    t0 = time()
    f()
    t1 = time()
    return t1 - t0

def test(m):
    tree = m.lol(5)
    assert(m.sum_tree(tree) == 57)
    assert(tree.sum() == 57)

    g = {**globals(), **locals()}
    sum = timeit('m.sum_tree(tree)', globals=g)
    sum2 = timeit('tree.sum()', globals=g)
    fsum = dumb_time(lambda: m.bench_sum(tree))
    fsum2 = dumb_time(lambda: m.bench_sum_method(tree))
    build = timeit('m.lol(5)', globals=g)
    return (sum, sum2, fsum, fsum2, build)

nsum, nsum2, nfsum, nfsum2, nbuild = test(native)
isum, isum2, ifsum, ifsum2, ibuild = test(interpreted)
print(nsum, nsum2, nfsum, nbuild)
print("Sum speedup:", isum/nsum)
print("Sum method speedup:", isum2/nsum2)
print("Sum (fast) speedup:", ifsum/nfsum)
print("Sum (fast) method speedup:", ifsum2/nfsum2)
print("Build speedup:", ibuild/nbuild)
