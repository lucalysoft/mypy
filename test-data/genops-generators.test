[case testYieldBasic]
from typing import Iterable

def yield_three_times() -> Iterable:
    yield 1
    yield 2

[out]
def yield_three_times_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: yield_three_times_gen
    type, value, traceback, arg :: object
    r0 :: yield_three_times_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: short_int
    r6 :: object
    r7 :: short_int
    r8 :: bool
    r9 :: object
    r10, r11 :: bool
    r12 :: None
    r13 :: short_int
    r14 :: object
    r15 :: short_int
    r16 :: bool
    r17 :: object
    r18, r19 :: bool
    r20, r21 :: None
    r22 :: object
    r23 :: short_int
    r24, r25 :: bool
    r26 :: short_int
    r27 :: bool
    r28 :: short_int
    r29 :: bool
    r30 :: short_int
    r31, r32 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L11
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = 1
    r6 = box(short_int, r5)
    r7 = 1
    r0.__mypyc_next_label__ = r7; r8 = is_error
    return r6
L4:
    r9 = builtins.None :: object
    r10 = type is not r9
    if r10 goto L5 else goto L6 :: bool
L5:
    raise_exception_with_tb(type, value, traceback); r11 = 0
    unreachable
L6:
    r12 = unbox(None, arg)
    r13 = 2
    r14 = box(short_int, r13)
    r15 = 2
    r0.__mypyc_next_label__ = r15; r16 = is_error
    return r14
L7:
    r17 = builtins.None :: object
    r18 = type is not r17
    if r18 goto L8 else goto L9 :: bool
L8:
    raise_exception_with_tb(type, value, traceback); r19 = 0
    unreachable
L9:
    r20 = unbox(None, arg)
    r21 = None
    r22 = box(None, r21)
    r23 = -1
    r0.__mypyc_next_label__ = r23; r24 = is_error
L10:
    raise StopIteration(r22)
    unreachable
L11:
    r26 = 0
    r27 = r1 == r26 :: int
    if r27 goto L1 else goto L12 :: bool
L12:
    r28 = 1
    r29 = r1 == r28 :: int
    if r29 goto L4 else goto L13 :: bool
L13:
    r30 = 2
    r31 = r1 == r30 :: int
    if r31 goto L7 else goto L14 :: bool
L14:
    raise StopIteration
    unreachable
def yield_three_times_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: yield_three_times_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_three_times_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def yield_three_times_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: yield_three_times_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_three_times_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def yield_three_times_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: yield_three_times_gen
L0:
    return __mypyc_self__
def yield_three_times_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: yield_three_times_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_three_times_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def yield_three_times():
    r0 :: yield_three_times_env
    r1 :: yield_three_times_gen
    r2 :: bool
    r3 :: short_int
    r4 :: bool
L0:
    r0 = yield_three_times_env()
    r1 = yield_three_times_gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1

[case testYieldWhileLoop]
from typing import Generator

def yield_while_loop() -> Generator:
    i = 0
    while i < 5:
        yield i
        i += 1

[out]
def yield_while_loop_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: yield_while_loop_gen
    type, value, traceback, arg :: object
    r0 :: yield_while_loop_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: short_int
    r6 :: bool
    r7 :: int
    r8 :: short_int
    r9 :: bool
    r10 :: int
    r11 :: object
    r12 :: short_int
    r13 :: bool
    r14 :: object
    r15, r16 :: bool
    r17 :: int
    r18 :: short_int
    r19 :: int
    r20 :: bool
    r21 :: None
    r22 :: object
    r23 :: short_int
    r24, r25 :: bool
    r26 :: short_int
    r27 :: bool
    r28 :: short_int
    r29, r30 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L11
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = 0
    r0.i = r5; r6 = is_error
L4:
    r7 = r0.i
    r8 = 5
    r9 = r7 < r8 :: int
    if r9 goto L5 else goto L9 :: bool
L5:
    r10 = r0.i
    r11 = box(int, r10)
    r12 = 1
    r0.__mypyc_next_label__ = r12; r13 = is_error
    return r11
L6:
    r14 = builtins.None :: object
    r15 = type is not r14
    if r15 goto L7 else goto L8 :: bool
L7:
    raise_exception_with_tb(type, value, traceback); r16 = 0
    unreachable
L8:
    r17 = r0.i
    r18 = 1
    r19 = r17 += r18 :: int
    r0.i = r19; r20 = is_error
    goto L4
L9:
    r21 = None
    r22 = box(None, r21)
    r23 = -1
    r0.__mypyc_next_label__ = r23; r24 = is_error
L10:
    raise StopIteration(r22)
    unreachable
L11:
    r26 = 0
    r27 = r1 == r26 :: int
    if r27 goto L1 else goto L12 :: bool
L12:
    r28 = 1
    r29 = r1 == r28 :: int
    if r29 goto L6 else goto L13 :: bool
L13:
    raise StopIteration
    unreachable
def yield_while_loop_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: yield_while_loop_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_while_loop_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def yield_while_loop_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: yield_while_loop_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_while_loop_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def yield_while_loop_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: yield_while_loop_gen
L0:
    return __mypyc_self__
def yield_while_loop_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: yield_while_loop_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_while_loop_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def yield_while_loop():
    r0 :: yield_while_loop_env
    r1 :: yield_while_loop_gen
    r2 :: bool
    r3 :: short_int
    r4 :: bool
L0:
    r0 = yield_while_loop_env()
    r1 = yield_while_loop_gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1

[case testYieldForLoops]
from typing import Iterable

def yield_for_loop_list() -> Iterable:
    l = [range(5)]
    for i in l:
        yield i

def yield_for_loop_dict() -> Iterable:
    d = {i: None for i in range(5)}
    for i in d:
        yield i

def yield_for_loop_range() -> Iterable:
    for i in range(5):
        yield i

[out]
def yield_for_loop_list_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: yield_for_loop_list_gen
    type, value, traceback, arg :: object
    r0 :: yield_for_loop_list_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: short_int
    r6 :: object
    r7 :: str
    r8, r9, r10 :: object
    r11 :: list
    r12 :: bool
    r13 :: list
    r14 :: bool
    r15 :: short_int
    r16 :: bool
    r17 :: list
    r18, r19 :: short_int
    r20 :: bool
    r21 :: list
    r22 :: short_int
    r23, r24 :: object
    r25 :: bool
    r26 :: object
    r27 :: short_int
    r28 :: bool
    r29 :: object
    r30, r31 :: bool
    r32 :: None
    r33, r34, r35 :: short_int
    r36 :: bool
    r37 :: None
    r38 :: object
    r39 :: short_int
    r40, r41 :: bool
    r42 :: short_int
    r43 :: bool
    r44 :: short_int
    r45, r46 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L12
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = 5
    r6 = builtins.module :: static
    r7 = unicode_3 :: static  ('range')
    r8 = getattr r6, r7
    r9 = box(short_int, r5)
    r10 = py_call(r8, r9)
    r11 = [r10]
    r0.l = r11; r12 = is_error
    r13 = r0.l
    r0.__mypyc_temp__0 = r13; r14 = is_error
    r15 = 0
    r0.__mypyc_temp__1 = r15; r16 = is_error
L4:
    r17 = r0.__mypyc_temp__0
    r18 = len r17 :: list
    r19 = r0.__mypyc_temp__1
    r20 = r19 < r18 :: short_int
    if r20 goto L5 else goto L10 :: bool
L5:
    r21 = r0.__mypyc_temp__0
    r22 = r0.__mypyc_temp__1
    r23 = r21[r22] :: unsafe list
    r24 = cast(object, r23)
    r0.i = r24; r25 = is_error
    r26 = r0.i
    r27 = 1
    r0.__mypyc_next_label__ = r27; r28 = is_error
    return r26
L6:
    r29 = builtins.None :: object
    r30 = type is not r29
    if r30 goto L7 else goto L8 :: bool
L7:
    raise_exception_with_tb(type, value, traceback); r31 = 0
    unreachable
L8:
    r32 = unbox(None, arg)
L9:
    r33 = r0.__mypyc_temp__1
    r34 = 1
    r35 = r33 + r34 :: short_int
    r0.__mypyc_temp__1 = r35; r36 = is_error
    goto L4
L10:
    r37 = None
    r38 = box(None, r37)
    r39 = -1
    r0.__mypyc_next_label__ = r39; r40 = is_error
L11:
    raise StopIteration(r38)
    unreachable
L12:
    r42 = 0
    r43 = r1 == r42 :: int
    if r43 goto L1 else goto L13 :: bool
L13:
    r44 = 1
    r45 = r1 == r44 :: int
    if r45 goto L6 else goto L14 :: bool
L14:
    raise StopIteration
    unreachable
def yield_for_loop_list_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: yield_for_loop_list_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_for_loop_list_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def yield_for_loop_list_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: yield_for_loop_list_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_for_loop_list_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def yield_for_loop_list_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: yield_for_loop_list_gen
L0:
    return __mypyc_self__
def yield_for_loop_list_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: yield_for_loop_list_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_for_loop_list_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def yield_for_loop_list():
    r0 :: yield_for_loop_list_env
    r1 :: yield_for_loop_list_gen
    r2 :: bool
    r3 :: short_int
    r4 :: bool
L0:
    r0 = yield_for_loop_list_env()
    r1 = yield_for_loop_list_gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1
def yield_for_loop_dict_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: yield_for_loop_dict_gen
    type, value, traceback, arg :: object
    r0 :: yield_for_loop_dict_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: dict
    r6, r7 :: short_int
    r8, r9 :: bool
    r10 :: int
    r11 :: short_int
    r12 :: bool
    r13 :: int
    r14 :: None
    r15, r16 :: object
    r17 :: bool
    r18 :: int
    r19, r20 :: short_int
    r21, r22 :: bool
    r23 :: dict
    r24 :: object
    r25, r26 :: bool
    r27, r28 :: object
    r29 :: int
    r30 :: bool
    r31 :: int
    r32 :: object
    r33 :: short_int
    r34 :: bool
    r35 :: object
    r36, r37 :: bool
    r38 :: None
    r39 :: bool
    r40 :: None
    r41 :: object
    r42 :: short_int
    r43, r44 :: bool
    r45 :: short_int
    r46 :: bool
    r47 :: short_int
    r48, r49 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L17
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = {}
    r6 = 0
    r7 = 5
    r0.__mypyc_temp__2 = r7; r8 = is_error
    r0.i = r6; r9 = is_error
L4:
    r10 = r0.i
    r11 = r0.__mypyc_temp__2
    r12 = r10 < r11 :: int
    if r12 goto L5 else goto L7 :: bool
L5:
    r13 = r0.i
    r14 = None
    r15 = box(int, r13)
    r16 = box(None, r14)
    r17 = r5.__setitem__(r15, r16) :: dict
L6:
    r18 = r0.i
    r19 = 1
    r20 = r18 + r19 :: short_int
    r0.i = r20; r21 = is_error
    goto L4
L7:
    r0.d = r5; r22 = is_error
    r23 = r0.d
    r24 = iter r23 :: object
    r0.__mypyc_temp__3 = r23; r25 = is_error
    r0.__mypyc_temp__4 = r24; r26 = is_error
L8:
    r27 = r0.__mypyc_temp__4
    r28 = next r27 :: object
    if is_error(r28) goto L14 else goto L9
L9:
    r29 = unbox(int, r28)
    r0.i = r29; r30 = is_error
    r31 = r0.i
    r32 = box(int, r31)
    r33 = 1
    r0.__mypyc_next_label__ = r33; r34 = is_error
    return r32
L10:
    r35 = builtins.None :: object
    r36 = type is not r35
    if r36 goto L11 else goto L12 :: bool
L11:
    raise_exception_with_tb(type, value, traceback); r37 = 0
    unreachable
L12:
    r38 = unbox(None, arg)
L13:
    goto L8
L14:
    r39 = no_err_occurred
L15:
    r40 = None
    r41 = box(None, r40)
    r42 = -1
    r0.__mypyc_next_label__ = r42; r43 = is_error
L16:
    raise StopIteration(r41)
    unreachable
L17:
    r45 = 0
    r46 = r1 == r45 :: int
    if r46 goto L1 else goto L18 :: bool
L18:
    r47 = 1
    r48 = r1 == r47 :: int
    if r48 goto L10 else goto L19 :: bool
L19:
    raise StopIteration
    unreachable
def yield_for_loop_dict_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: yield_for_loop_dict_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_for_loop_dict_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def yield_for_loop_dict_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: yield_for_loop_dict_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_for_loop_dict_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def yield_for_loop_dict_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: yield_for_loop_dict_gen
L0:
    return __mypyc_self__
def yield_for_loop_dict_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: yield_for_loop_dict_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_for_loop_dict_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def yield_for_loop_dict():
    r0 :: yield_for_loop_dict_env
    r1 :: yield_for_loop_dict_gen
    r2 :: bool
    r3 :: short_int
    r4 :: bool
L0:
    r0 = yield_for_loop_dict_env()
    r1 = yield_for_loop_dict_gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1
def yield_for_loop_range_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: yield_for_loop_range_gen
    type, value, traceback, arg :: object
    r0 :: yield_for_loop_range_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5, r6 :: short_int
    r7, r8 :: bool
    r9 :: int
    r10 :: short_int
    r11 :: bool
    r12 :: int
    r13 :: object
    r14 :: short_int
    r15 :: bool
    r16 :: object
    r17, r18 :: bool
    r19 :: None
    r20 :: int
    r21, r22 :: short_int
    r23 :: bool
    r24 :: None
    r25 :: object
    r26 :: short_int
    r27, r28 :: bool
    r29 :: short_int
    r30 :: bool
    r31 :: short_int
    r32, r33 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L12
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = 0
    r6 = 5
    r0.__mypyc_temp__5 = r6; r7 = is_error
    r0.i = r5; r8 = is_error
L4:
    r9 = r0.i
    r10 = r0.__mypyc_temp__5
    r11 = r9 < r10 :: int
    if r11 goto L5 else goto L10 :: bool
L5:
    r12 = r0.i
    r13 = box(int, r12)
    r14 = 1
    r0.__mypyc_next_label__ = r14; r15 = is_error
    return r13
L6:
    r16 = builtins.None :: object
    r17 = type is not r16
    if r17 goto L7 else goto L8 :: bool
L7:
    raise_exception_with_tb(type, value, traceback); r18 = 0
    unreachable
L8:
    r19 = unbox(None, arg)
L9:
    r20 = r0.i
    r21 = 1
    r22 = r20 + r21 :: short_int
    r0.i = r22; r23 = is_error
    goto L4
L10:
    r24 = None
    r25 = box(None, r24)
    r26 = -1
    r0.__mypyc_next_label__ = r26; r27 = is_error
L11:
    raise StopIteration(r25)
    unreachable
L12:
    r29 = 0
    r30 = r1 == r29 :: int
    if r30 goto L1 else goto L13 :: bool
L13:
    r31 = 1
    r32 = r1 == r31 :: int
    if r32 goto L6 else goto L14 :: bool
L14:
    raise StopIteration
    unreachable
def yield_for_loop_range_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: yield_for_loop_range_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_for_loop_range_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def yield_for_loop_range_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: yield_for_loop_range_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_for_loop_range_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def yield_for_loop_range_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: yield_for_loop_range_gen
L0:
    return __mypyc_self__
def yield_for_loop_range_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: yield_for_loop_range_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_for_loop_range_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def yield_for_loop_range():
    r0 :: yield_for_loop_range_env
    r1 :: yield_for_loop_range_gen
    r2 :: bool
    r3 :: short_int
    r4 :: bool
L0:
    r0 = yield_for_loop_range_env()
    r1 = yield_for_loop_range_gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1

[case testYieldComplex]
from typing import Generator

def yield_with_vars(a: int, b: float) -> Generator[int, None, float]:
    x = 2
    while x < a:
        yield x
        x += 1
    return b

[out]
def yield_with_vars_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: yield_with_vars_gen
    type, value, traceback, arg :: object
    r0 :: yield_with_vars_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: short_int
    r6 :: bool
    r7, r8 :: int
    r9 :: bool
    r10 :: int
    r11 :: object
    r12 :: short_int
    r13 :: bool
    r14 :: object
    r15, r16 :: bool
    r17 :: None
    r18 :: int
    r19 :: short_int
    r20 :: int
    r21 :: bool
    r22 :: float
    r23 :: short_int
    r24, r25 :: bool
    r26 :: short_int
    r27 :: bool
    r28 :: short_int
    r29, r30 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L11
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = 2
    r0.x = r5; r6 = is_error
L4:
    r7 = r0.x
    r8 = r0.a
    r9 = r7 < r8 :: int
    if r9 goto L5 else goto L9 :: bool
L5:
    r10 = r0.x
    r11 = box(int, r10)
    r12 = 1
    r0.__mypyc_next_label__ = r12; r13 = is_error
    return r11
L6:
    r14 = builtins.None :: object
    r15 = type is not r14
    if r15 goto L7 else goto L8 :: bool
L7:
    raise_exception_with_tb(type, value, traceback); r16 = 0
    unreachable
L8:
    r17 = unbox(None, arg)
    r18 = r0.x
    r19 = 1
    r20 = r18 += r19 :: int
    r0.x = r20; r21 = is_error
    goto L4
L9:
    r22 = r0.b
    r23 = -1
    r0.__mypyc_next_label__ = r23; r24 = is_error
L10:
    raise StopIteration(r22)
    unreachable
L11:
    r26 = 0
    r27 = r1 == r26 :: int
    if r27 goto L1 else goto L12 :: bool
L12:
    r28 = 1
    r29 = r1 == r28 :: int
    if r29 goto L6 else goto L13 :: bool
L13:
    raise StopIteration
    unreachable
def yield_with_vars_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: yield_with_vars_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_with_vars_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def yield_with_vars_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: yield_with_vars_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_with_vars_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def yield_with_vars_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: yield_with_vars_gen
L0:
    return __mypyc_self__
def yield_with_vars_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: yield_with_vars_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_with_vars_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def yield_with_vars(a, b):
    a :: int
    b :: float
    r0 :: yield_with_vars_env
    r1, r2 :: bool
    r3 :: yield_with_vars_gen
    r4 :: bool
    r5 :: short_int
    r6 :: bool
L0:
    r0 = yield_with_vars_env()
    r0.a = a; r1 = is_error
    r0.b = b; r2 = is_error
    r3 = yield_with_vars_gen()
    r3.__mypyc_env__ = r0; r4 = is_error
    r5 = 0
    r0.__mypyc_next_label__ = r5; r6 = is_error
    return r3

[case testYieldInsideMethod]
from typing import Iterable

class A(object):
    def generator(self) -> Iterable[int]:
        yield 0

[out]
def generator_A_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: generator_A_gen
    type, value, traceback, arg :: object
    r0 :: generator_A_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: short_int
    r6 :: object
    r7 :: short_int
    r8 :: bool
    r9 :: object
    r10, r11 :: bool
    r12, r13 :: None
    r14 :: object
    r15 :: short_int
    r16, r17 :: bool
    r18 :: short_int
    r19 :: bool
    r20 :: short_int
    r21, r22 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L8
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = 0
    r6 = box(short_int, r5)
    r7 = 1
    r0.__mypyc_next_label__ = r7; r8 = is_error
    return r6
L4:
    r9 = builtins.None :: object
    r10 = type is not r9
    if r10 goto L5 else goto L6 :: bool
L5:
    raise_exception_with_tb(type, value, traceback); r11 = 0
    unreachable
L6:
    r12 = unbox(None, arg)
    r13 = None
    r14 = box(None, r13)
    r15 = -1
    r0.__mypyc_next_label__ = r15; r16 = is_error
L7:
    raise StopIteration(r14)
    unreachable
L8:
    r18 = 0
    r19 = r1 == r18 :: int
    if r19 goto L1 else goto L9 :: bool
L9:
    r20 = 1
    r21 = r1 == r20 :: int
    if r21 goto L4 else goto L10 :: bool
L10:
    raise StopIteration
    unreachable
def generator_A_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: generator_A_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_A_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def generator_A_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: generator_A_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_A_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def generator_A_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: generator_A_gen
L0:
    return __mypyc_self__
def generator_A_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: generator_A_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator_A_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def A.generator(self):
    self :: A
    r0 :: generator_A_env
    r1 :: bool
    r2 :: generator_A_gen
    r3 :: bool
    r4 :: short_int
    r5 :: bool
L0:
    r0 = generator_A_env()
    r0.self = self; r1 = is_error
    r2 = generator_A_gen()
    r2.__mypyc_env__ = r0; r3 = is_error
    r4 = 0
    r0.__mypyc_next_label__ = r4; r5 = is_error
    return r2

[case testYieldIfElse]
from typing import Generator

def generator(a: int) -> Generator:
    if a < 5:
        yield a
    else:
        return

[out]
def generator_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: generator_gen
    type, value, traceback, arg :: object
    r0 :: generator_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: int
    r6 :: short_int
    r7 :: bool
    r8 :: int
    r9 :: object
    r10 :: short_int
    r11 :: bool
    r12 :: object
    r13, r14 :: bool
    r15 :: None
    r16 :: object
    r17 :: short_int
    r18, r19 :: bool
    r20 :: None
    r21 :: object
    r22 :: short_int
    r23, r24 :: bool
    r25 :: short_int
    r26 :: bool
    r27 :: short_int
    r28, r29 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L12
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = r0.a
    r6 = 5
    r7 = r5 < r6 :: int
    if r7 goto L4 else goto L8 :: bool
L4:
    r8 = r0.a
    r9 = box(int, r8)
    r10 = 1
    r0.__mypyc_next_label__ = r10; r11 = is_error
    return r9
L5:
    r12 = builtins.None :: object
    r13 = type is not r12
    if r13 goto L6 else goto L7 :: bool
L6:
    raise_exception_with_tb(type, value, traceback); r14 = 0
    unreachable
L7:
    goto L10
L8:
    r15 = None
    r16 = box(None, r15)
    r17 = -1
    r0.__mypyc_next_label__ = r17; r18 = is_error
L9:
    raise StopIteration(r16)
    unreachable
L10:
    r20 = None
    r21 = box(None, r20)
    r22 = -1
    r0.__mypyc_next_label__ = r22; r23 = is_error
L11:
    raise StopIteration(r21)
    unreachable
L12:
    r25 = 0
    r26 = r1 == r25 :: int
    if r26 goto L1 else goto L13 :: bool
L13:
    r27 = 1
    r28 = r1 == r27 :: int
    if r28 goto L5 else goto L14 :: bool
L14:
    raise StopIteration
    unreachable
def generator_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: generator_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def generator_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: generator_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def generator_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: generator_gen
L0:
    return __mypyc_self__
def generator_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: generator_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def generator(a):
    a :: int
    r0 :: generator_env
    r1 :: bool
    r2 :: generator_gen
    r3 :: bool
    r4 :: short_int
    r5 :: bool
L0:
    r0 = generator_env()
    r0.a = a; r1 = is_error
    r2 = generator_gen()
    r2.__mypyc_env__ = r0; r3 = is_error
    r4 = 0
    r0.__mypyc_next_label__ = r4; r5 = is_error
    return r2

[case testYieldNested]
from typing import Callable, Generator

def generator(a: int) -> Generator:
    def normal(x: int) -> int:
        return a + x
    yield normal(1)

def normal(a: int) -> Callable:
    def generator(x: int) -> Generator:
        yield a
        yield x
    return generator

def triple() -> Callable:
    def generator() -> Generator:
        x = 0
        def inner() -> int:
            x += 1
            return x
        while x < 3:
            yield inner()
    return generator

def outer() -> Generator:
    def recursive(n: int) -> Generator:
        if n < 10:
            for i in range(n):
                yield i
            return
        for i in recursive(5):
            yield i
    return recursive(10)

[out]
def normal_generator_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bool
    r2 :: object
L0:
    r0 = builtins.None :: object
    r1 = instance is r0
    if r1 goto L1 else goto L2 :: bool
L1:
    return __mypyc_self__
L2:
    r2 = method_new __mypyc_self__, instance
    return r2
def normal_generator_obj.__call__(__mypyc_self__, x):
    __mypyc_self__ :: normal_generator_obj
    x :: int
    r0 :: generator_env
    r1, normal :: object
    r2, r3 :: int
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.normal
    normal = r1
    r2 = r0.a
    r3 = r2 + x :: int
    return r3
def generator_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: generator_gen
    type, value, traceback, arg :: object
    r0 :: generator_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: normal_generator_obj
    r6, r7 :: bool
    r8 :: short_int
    r9, r10, r11 :: object
    r12 :: int
    r13 :: object
    r14 :: short_int
    r15 :: bool
    r16 :: object
    r17, r18 :: bool
    r19 :: None
    r20 :: object
    r21 :: short_int
    r22, r23 :: bool
    r24 :: short_int
    r25 :: bool
    r26 :: short_int
    r27, r28 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L8
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = normal_generator_obj()
    r5.__mypyc_env__ = r0; r6 = is_error
    r0.normal = r5; r7 = is_error
    r8 = 1
    r9 = r0.normal
    r10 = box(short_int, r8)
    r11 = py_call(r9, r10)
    r12 = unbox(int, r11)
    r13 = box(int, r12)
    r14 = 1
    r0.__mypyc_next_label__ = r14; r15 = is_error
    return r13
L4:
    r16 = builtins.None :: object
    r17 = type is not r16
    if r17 goto L5 else goto L6 :: bool
L5:
    raise_exception_with_tb(type, value, traceback); r18 = 0
    unreachable
L6:
    r19 = None
    r20 = box(None, r19)
    r21 = -1
    r0.__mypyc_next_label__ = r21; r22 = is_error
L7:
    raise StopIteration(r20)
    unreachable
L8:
    r24 = 0
    r25 = r1 == r24 :: int
    if r25 goto L1 else goto L9 :: bool
L9:
    r26 = 1
    r27 = r1 == r26 :: int
    if r27 goto L4 else goto L10 :: bool
L10:
    raise StopIteration
    unreachable
def generator_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: generator_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def generator_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: generator_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def generator_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: generator_gen
L0:
    return __mypyc_self__
def generator_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: generator_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def generator(a):
    a :: int
    r0 :: generator_env
    r1 :: bool
    r2 :: generator_gen
    r3 :: bool
    r4 :: short_int
    r5 :: bool
L0:
    r0 = generator_env()
    r0.a = a; r1 = is_error
    r2 = generator_gen()
    r2.__mypyc_env__ = r0; r3 = is_error
    r4 = 0
    r0.__mypyc_next_label__ = r4; r5 = is_error
    return r2
def generator_normal_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bool
    r2 :: object
L0:
    r0 = builtins.None :: object
    r1 = instance is r0
    if r1 goto L1 else goto L2 :: bool
L1:
    return __mypyc_self__
L2:
    r2 = method_new __mypyc_self__, instance
    return r2
def generator_normal_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: generator_normal_gen
    type, value, traceback, arg :: object
    r0 :: generator_normal_env
    r1 :: int
    r2, r3 :: normal_env
    r4, generator, r5 :: object
    r6, r7 :: bool
    r8 :: int
    r9 :: object
    r10 :: short_int
    r11 :: bool
    r12 :: object
    r13, r14 :: bool
    r15 :: int
    r16 :: object
    r17 :: short_int
    r18 :: bool
    r19 :: object
    r20, r21 :: bool
    r22 :: None
    r23 :: object
    r24 :: short_int
    r25, r26 :: bool
    r27 :: short_int
    r28 :: bool
    r29 :: short_int
    r30 :: bool
    r31 :: short_int
    r32, r33 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    r2 = r0.__mypyc_env__
    r3 = r0.__mypyc_env__
    r4 = r3.generator
    generator = r4
    goto L11
L1:
    r5 = builtins.None :: object
    r6 = type is not r5
    if r6 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r7 = 0
    unreachable
L3:
    r8 = r2.a
    r9 = box(int, r8)
    r10 = 1
    r0.__mypyc_next_label__ = r10; r11 = is_error
    return r9
L4:
    r12 = builtins.None :: object
    r13 = type is not r12
    if r13 goto L5 else goto L6 :: bool
L5:
    raise_exception_with_tb(type, value, traceback); r14 = 0
    unreachable
L6:
    r15 = r0.x
    r16 = box(int, r15)
    r17 = 2
    r0.__mypyc_next_label__ = r17; r18 = is_error
    return r16
L7:
    r19 = builtins.None :: object
    r20 = type is not r19
    if r20 goto L8 else goto L9 :: bool
L8:
    raise_exception_with_tb(type, value, traceback); r21 = 0
    unreachable
L9:
    r22 = None
    r23 = box(None, r22)
    r24 = -1
    r0.__mypyc_next_label__ = r24; r25 = is_error
L10:
    raise StopIteration(r23)
    unreachable
L11:
    r27 = 0
    r28 = r1 == r27 :: int
    if r28 goto L1 else goto L12 :: bool
L12:
    r29 = 1
    r30 = r1 == r29 :: int
    if r30 goto L4 else goto L13 :: bool
L13:
    r31 = 2
    r32 = r1 == r31 :: int
    if r32 goto L7 else goto L14 :: bool
L14:
    raise StopIteration
    unreachable
def generator_normal_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: generator_normal_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_normal_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def generator_normal_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: generator_normal_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_normal_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def generator_normal_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: generator_normal_gen
L0:
    return __mypyc_self__
def generator_normal_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: generator_normal_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator_normal_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def generator_normal_obj.__call__(__mypyc_self__, x):
    __mypyc_self__ :: generator_normal_obj
    x :: int
    r0 :: normal_env
    r1, generator :: object
    r2 :: generator_normal_env
    r3, r4 :: bool
    r5 :: generator_normal_gen
    r6 :: bool
    r7 :: short_int
    r8 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.generator
    generator = r1
    r2 = generator_normal_env()
    r2.__mypyc_env__ = r0; r3 = is_error
    r2.x = x; r4 = is_error
    r5 = generator_normal_gen()
    r5.__mypyc_env__ = r2; r6 = is_error
    r7 = 0
    r2.__mypyc_next_label__ = r7; r8 = is_error
    return r5
def normal(a):
    a :: int
    r0 :: normal_env
    r1 :: bool
    r2 :: generator_normal_obj
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = normal_env()
    r0.a = a; r1 = is_error
    r2 = generator_normal_obj()
    r2.__mypyc_env__ = r0; r3 = is_error
    r0.generator = r2; r4 = is_error
    r5 = r0.generator
    return r5
def generator_triple_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bool
    r2 :: object
L0:
    r0 = builtins.None :: object
    r1 = instance is r0
    if r1 goto L1 else goto L2 :: bool
L1:
    return __mypyc_self__
L2:
    r2 = method_new __mypyc_self__, instance
    return r2
def inner_triple_generator_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bool
    r2 :: object
L0:
    r0 = builtins.None :: object
    r1 = instance is r0
    if r1 goto L1 else goto L2 :: bool
L1:
    return __mypyc_self__
L2:
    r2 = method_new __mypyc_self__, instance
    return r2
def inner_triple_generator_obj.__call__(__mypyc_self__):
    __mypyc_self__ :: inner_triple_generator_obj
    r0 :: generator_triple_env
    r1 :: triple_env
    r2, inner :: object
    r3 :: int
    r4 :: short_int
    r5 :: int
    r6 :: bool
    r7 :: int
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_env__
    r2 = r0.inner
    inner = r2
    r3 = r0.x
    r4 = 1
    r5 = r3 += r4 :: int
    r0.x = r5; r6 = is_error
    r7 = r0.x
    return r7
def generator_triple_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: generator_triple_gen
    type, value, traceback, arg :: object
    r0 :: generator_triple_env
    r1 :: int
    r2, r3 :: triple_env
    r4, generator, r5 :: object
    r6, r7 :: bool
    r8 :: short_int
    r9 :: bool
    r10 :: inner_triple_generator_obj
    r11, r12 :: bool
    r13 :: int
    r14 :: short_int
    r15 :: bool
    r16, r17 :: object
    r18 :: int
    r19 :: object
    r20 :: short_int
    r21 :: bool
    r22 :: object
    r23, r24 :: bool
    r25 :: None
    r26 :: object
    r27 :: short_int
    r28, r29 :: bool
    r30 :: short_int
    r31 :: bool
    r32 :: short_int
    r33, r34 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    r2 = r0.__mypyc_env__
    r3 = r0.__mypyc_env__
    r4 = r3.generator
    generator = r4
    goto L11
L1:
    r5 = builtins.None :: object
    r6 = type is not r5
    if r6 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r7 = 0
    unreachable
L3:
    r8 = 0
    r0.x = r8; r9 = is_error
    r10 = inner_triple_generator_obj()
    r10.__mypyc_env__ = r0; r11 = is_error
    r0.inner = r10; r12 = is_error
L4:
    r13 = r0.x
    r14 = 3
    r15 = r13 < r14 :: int
    if r15 goto L5 else goto L9 :: bool
L5:
    r16 = r0.inner
    r17 = py_call(r16)
    r18 = unbox(int, r17)
    r19 = box(int, r18)
    r20 = 1
    r0.__mypyc_next_label__ = r20; r21 = is_error
    return r19
L6:
    r22 = builtins.None :: object
    r23 = type is not r22
    if r23 goto L7 else goto L8 :: bool
L7:
    raise_exception_with_tb(type, value, traceback); r24 = 0
    unreachable
L8:
    goto L4
L9:
    r25 = None
    r26 = box(None, r25)
    r27 = -1
    r0.__mypyc_next_label__ = r27; r28 = is_error
L10:
    raise StopIteration(r26)
    unreachable
L11:
    r30 = 0
    r31 = r1 == r30 :: int
    if r31 goto L1 else goto L12 :: bool
L12:
    r32 = 1
    r33 = r1 == r32 :: int
    if r33 goto L6 else goto L13 :: bool
L13:
    raise StopIteration
    unreachable
def generator_triple_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: generator_triple_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_triple_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def generator_triple_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: generator_triple_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = generator_triple_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def generator_triple_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: generator_triple_gen
L0:
    return __mypyc_self__
def generator_triple_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: generator_triple_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = generator_triple_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def generator_triple_obj.__call__(__mypyc_self__):
    __mypyc_self__ :: generator_triple_obj
    r0 :: triple_env
    r1, generator :: object
    r2 :: generator_triple_env
    r3 :: bool
    r4 :: generator_triple_gen
    r5 :: bool
    r6 :: short_int
    r7 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.generator
    generator = r1
    r2 = generator_triple_env()
    r2.__mypyc_env__ = r0; r3 = is_error
    r4 = generator_triple_gen()
    r4.__mypyc_env__ = r2; r5 = is_error
    r6 = 0
    r2.__mypyc_next_label__ = r6; r7 = is_error
    return r4
def triple():
    r0 :: triple_env
    r1 :: generator_triple_obj
    r2, r3 :: bool
    r4 :: object
L0:
    r0 = triple_env()
    r1 = generator_triple_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    r0.generator = r1; r3 = is_error
    r4 = r0.generator
    return r4
def recursive_outer_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bool
    r2 :: object
L0:
    r0 = builtins.None :: object
    r1 = instance is r0
    if r1 goto L1 else goto L2 :: bool
L1:
    return __mypyc_self__
L2:
    r2 = method_new __mypyc_self__, instance
    return r2
def recursive_outer_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: recursive_outer_gen
    type, value, traceback, arg :: object
    r0 :: recursive_outer_env
    r1 :: int
    r2, r3 :: outer_env
    r4, recursive, r5 :: object
    r6, r7 :: bool
    r8 :: int
    r9 :: short_int
    r10 :: bool
    r11 :: short_int
    r12 :: int
    r13, r14 :: bool
    r15, r16 :: int
    r17 :: bool
    r18 :: int
    r19 :: object
    r20 :: short_int
    r21 :: bool
    r22 :: object
    r23, r24 :: bool
    r25 :: int
    r26 :: short_int
    r27 :: int
    r28 :: bool
    r29 :: None
    r30 :: object
    r31 :: short_int
    r32, r33 :: bool
    r34 :: short_int
    r35, r36, r37 :: object
    r38, r39 :: bool
    r40, r41 :: object
    r42 :: int
    r43 :: bool
    r44 :: int
    r45 :: object
    r46 :: short_int
    r47 :: bool
    r48 :: object
    r49, r50, r51 :: bool
    r52 :: None
    r53 :: object
    r54 :: short_int
    r55, r56 :: bool
    r57 :: short_int
    r58 :: bool
    r59 :: short_int
    r60 :: bool
    r61 :: short_int
    r62, r63 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    r2 = r0.__mypyc_env__
    r3 = r0.__mypyc_env__
    r4 = r3.recursive
    recursive = r4
    goto L23
L1:
    r5 = builtins.None :: object
    r6 = type is not r5
    if r6 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r7 = 0
    unreachable
L3:
    r8 = r0.n
    r9 = 10
    r10 = r8 < r9 :: int
    if r10 goto L4 else goto L13 :: bool
L4:
    r11 = 0
    r12 = r0.n
    r0.__mypyc_temp__0 = r12; r13 = is_error
    r0.i = r11; r14 = is_error
L5:
    r15 = r0.i
    r16 = r0.__mypyc_temp__0
    r17 = r15 < r16 :: int
    if r17 goto L6 else goto L11 :: bool
L6:
    r18 = r0.i
    r19 = box(int, r18)
    r20 = 1
    r0.__mypyc_next_label__ = r20; r21 = is_error
    return r19
L7:
    r22 = builtins.None :: object
    r23 = type is not r22
    if r23 goto L8 else goto L9 :: bool
L8:
    raise_exception_with_tb(type, value, traceback); r24 = 0
    unreachable
L9:
L10:
    r25 = r0.i
    r26 = 1
    r27 = r25 + r26 :: int
    r0.i = r27; r28 = is_error
    goto L5
L11:
    r29 = None
    r30 = box(None, r29)
    r31 = -1
    r0.__mypyc_next_label__ = r31; r32 = is_error
L12:
    raise StopIteration(r30)
    unreachable
L13:
    r34 = 5
    r35 = box(short_int, r34)
    r36 = py_call(recursive, r35)
    r37 = iter r36 :: object
    r0.__mypyc_temp__1 = r36; r38 = is_error
    r0.__mypyc_temp__2 = r37; r39 = is_error
L14:
    r40 = r0.__mypyc_temp__2
    r41 = next r40 :: object
    if is_error(r41) goto L20 else goto L15
L15:
    r42 = unbox(int, r41)
    r0.i = r42; r43 = is_error
    r44 = r0.i
    r45 = box(int, r44)
    r46 = 2
    r0.__mypyc_next_label__ = r46; r47 = is_error
    return r45
L16:
    r48 = builtins.None :: object
    r49 = type is not r48
    if r49 goto L17 else goto L18 :: bool
L17:
    raise_exception_with_tb(type, value, traceback); r50 = 0
    unreachable
L18:
L19:
    goto L14
L20:
    r51 = no_err_occurred
L21:
    r52 = None
    r53 = box(None, r52)
    r54 = -1
    r0.__mypyc_next_label__ = r54; r55 = is_error
L22:
    raise StopIteration(r53)
    unreachable
L23:
    r57 = 0
    r58 = r1 == r57 :: int
    if r58 goto L1 else goto L24 :: bool
L24:
    r59 = 1
    r60 = r1 == r59 :: int
    if r60 goto L7 else goto L25 :: bool
L25:
    r61 = 2
    r62 = r1 == r61 :: int
    if r62 goto L16 else goto L26 :: bool
L26:
    raise StopIteration
    unreachable
def recursive_outer_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: recursive_outer_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = recursive_outer_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def recursive_outer_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: recursive_outer_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = recursive_outer_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def recursive_outer_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: recursive_outer_gen
L0:
    return __mypyc_self__
def recursive_outer_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: recursive_outer_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = recursive_outer_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def recursive_outer_obj.__call__(__mypyc_self__, n):
    __mypyc_self__ :: recursive_outer_obj
    n :: int
    r0 :: outer_env
    r1, recursive :: object
    r2 :: recursive_outer_env
    r3, r4 :: bool
    r5 :: recursive_outer_gen
    r6 :: bool
    r7 :: short_int
    r8 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.recursive
    recursive = r1
    r2 = recursive_outer_env()
    r2.__mypyc_env__ = r0; r3 = is_error
    r2.n = n; r4 = is_error
    r5 = recursive_outer_gen()
    r5.__mypyc_env__ = r2; r6 = is_error
    r7 = 0
    r2.__mypyc_next_label__ = r7; r8 = is_error
    return r5
def outer():
    r0 :: outer_env
    r1 :: recursive_outer_obj
    r2, r3 :: bool
    r4 :: short_int
    r5, r6, r7 :: object
L0:
    r0 = outer_env()
    r1 = recursive_outer_obj()
    r1.__mypyc_env__ = r0; r2 = is_error
    r0.recursive = r1; r3 = is_error
    r4 = 10
    r5 = r0.recursive
    r6 = box(short_int, r4)
    r7 = py_call(r5, r6)
    return r7

[case testYieldTryFinally]
from typing import Generator

def yield_try_finally() -> Generator[int, None, str]:
    try:
        yield 1
        yield 2
        return 'lol'
    except Exception:
        raise
    finally:
        print('goodbye!')

[out]
def yield_try_finally_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: yield_try_finally_gen
    type, value, traceback, arg :: object
    r0 :: yield_try_finally_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: short_int
    r6 :: object
    r7 :: short_int
    r8 :: bool
    r9 :: object
    r10, r11 :: bool
    r12 :: None
    r13 :: short_int
    r14 :: object
    r15 :: short_int
    r16 :: bool
    r17 :: object
    r18, r19 :: bool
    r20 :: None
    r21 :: str
    r22 :: object
    r23 :: tuple[object, object, object]
    r24 :: object
    r25 :: str
    r26 :: object
    r27, r28, r29, r30 :: bool
    r31 :: tuple[object, object, object]
    r32 :: object
    r33 :: tuple[object, object, object]
    r34 :: object
    r35 :: tuple[object, object, object]
    r36 :: str
    r37 :: object
    r38 :: str
    r39, r40 :: object
    r41 :: None
    r42 :: bool
    r43 :: short_int
    r44, r45, r46 :: bool
    r47 :: None
    r48 :: object
    r49 :: short_int
    r50, r51 :: bool
    r52 :: short_int
    r53 :: bool
    r54 :: short_int
    r55 :: bool
    r56 :: short_int
    r57, r58 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L33
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
L4:
L5:
    r5 = 1
    r6 = box(short_int, r5)
    r7 = 1
    r0.__mypyc_next_label__ = r7; r8 = is_error
    return r6
L6:
    r9 = builtins.None :: object
    r10 = type is not r9
    if r10 goto L7 else goto L8 :: bool
L7:
    raise_exception_with_tb(type, value, traceback); r11 = 0
    unreachable
L8:
    r12 = unbox(None, arg)
    r13 = 2
    r14 = box(short_int, r13)
    r15 = 2
    r0.__mypyc_next_label__ = r15; r16 = is_error
    return r14
L9:
    r17 = builtins.None :: object
    r18 = type is not r17
    if r18 goto L10 else goto L11 :: bool
L10:
    raise_exception_with_tb(type, value, traceback); r19 = 0
    unreachable
L11:
    r20 = unbox(None, arg)
    r21 = unicode_3 :: static  ('lol')
    r22 = r21
    goto L19
L12: (handler for L10, L11, L5, L6, L7, L8, L9)
    r23 = error_catch
    r24 = builtins.module :: static
    r25 = unicode_4 :: static  ('Exception')
    r26 = getattr r24, r25
    r27 = exc_matches r26
    if r27 goto L13 else goto L14 :: bool
L13:
    reraise_exc; r28 = 0
    unreachable
L14:
    reraise_exc; r29 = 0
    unreachable
L15:
    restore_exc_info r23
    goto L17
L16: (handler for L12, L13, L14)
    restore_exc_info r23
    r30 = keep_propagating
    unreachable
L17:
L18:
    r32 = <error> :: object
    r22 = r32
L19:
    r33 = <error> :: tuple[object, object, object]
    r31 = r33
    goto L21
L20: (handler for L15, L16, L17, L4)
    r34 = <error> :: object
    r22 = r34
    r35 = error_catch
    r31 = r35
L21:
    r36 = unicode_5 :: static  ('goodbye!')
    r37 = builtins.module :: static
    r38 = unicode_6 :: static  ('print')
    r39 = getattr r37, r38
    r40 = py_call(r39, r36)
    r41 = unbox(None, r40)
    if is_error(r31) goto L23 else goto L22
L22:
    reraise_exc; r42 = 0
    unreachable
L23:
    if is_error(r22) goto L26 else goto L24
L24:
    r43 = -1
    r0.__mypyc_next_label__ = r43; r44 = is_error
L25:
    raise StopIteration(r22)
    unreachable
L26:
    goto L31
L27: (handler for L21, L22)
    if is_error(r22) goto L28 else goto L28
L28:
    if is_error(r31) goto L30 else goto L29
L29:
    restore_exc_info r31
L30:
    r46 = keep_propagating
    unreachable
L31:
    r47 = None
    r48 = box(None, r47)
    r49 = -1
    r0.__mypyc_next_label__ = r49; r50 = is_error
L32:
    raise StopIteration(r48)
    unreachable
L33:
    r52 = 0
    r53 = r1 == r52 :: int
    if r53 goto L1 else goto L34 :: bool
L34:
    r54 = 1
    r55 = r1 == r54 :: int
    if r55 goto L6 else goto L35 :: bool
L35:
    r56 = 2
    r57 = r1 == r56 :: int
    if r57 goto L9 else goto L36 :: bool
L36:
    raise StopIteration
    unreachable
def yield_try_finally_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: yield_try_finally_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_try_finally_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def yield_try_finally_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: yield_try_finally_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = yield_try_finally_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def yield_try_finally_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: yield_try_finally_gen
L0:
    return __mypyc_self__
def yield_try_finally_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: yield_try_finally_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = yield_try_finally_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def yield_try_finally():
    r0 :: yield_try_finally_env
    r1 :: yield_try_finally_gen
    r2 :: bool
    r3 :: short_int
    r4 :: bool
L0:
    r0 = yield_try_finally_env()
    r1 = yield_try_finally_gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1

[case testYieldSend]
from typing import Generator

def basic() -> Generator[None, int, None]:
    x = yield
    y = yield
[out]
def basic_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: basic_gen
    type, value, traceback, arg :: object
    r0 :: basic_env
    r1 :: int
    r2 :: object
    r3, r4 :: bool
    r5 :: None
    r6 :: object
    r7 :: short_int
    r8 :: bool
    r9 :: object
    r10, r11 :: bool
    r12 :: int
    r13 :: bool
    r14 :: None
    r15 :: object
    r16 :: short_int
    r17 :: bool
    r18 :: object
    r19, r20 :: bool
    r21 :: int
    r22 :: bool
    r23 :: None
    r24 :: object
    r25 :: short_int
    r26, r27 :: bool
    r28 :: short_int
    r29 :: bool
    r30 :: short_int
    r31 :: bool
    r32 :: short_int
    r33, r34 :: bool
L0:
    r0 = __mypyc_self__.__mypyc_env__
    r1 = r0.__mypyc_next_label__
    goto L11
L1:
    r2 = builtins.None :: object
    r3 = type is not r2
    if r3 goto L2 else goto L3 :: bool
L2:
    raise_exception_with_tb(type, value, traceback); r4 = 0
    unreachable
L3:
    r5 = None
    r6 = box(None, r5)
    r7 = 1
    r0.__mypyc_next_label__ = r7; r8 = is_error
    return r6
L4:
    r9 = builtins.None :: object
    r10 = type is not r9
    if r10 goto L5 else goto L6 :: bool
L5:
    raise_exception_with_tb(type, value, traceback); r11 = 0
    unreachable
L6:
    r12 = unbox(int, arg)
    r0.x = r12; r13 = is_error
    r14 = None
    r15 = box(None, r14)
    r16 = 2
    r0.__mypyc_next_label__ = r16; r17 = is_error
    return r15
L7:
    r18 = builtins.None :: object
    r19 = type is not r18
    if r19 goto L8 else goto L9 :: bool
L8:
    raise_exception_with_tb(type, value, traceback); r20 = 0
    unreachable
L9:
    r21 = unbox(int, arg)
    r0.y = r21; r22 = is_error
    r23 = None
    r24 = box(None, r23)
    r25 = -1
    r0.__mypyc_next_label__ = r25; r26 = is_error
L10:
    raise StopIteration(r24)
    unreachable
L11:
    r28 = 0
    r29 = r1 == r28 :: int
    if r29 goto L1 else goto L12 :: bool
L12:
    r30 = 1
    r31 = r1 == r30 :: int
    if r31 goto L4 else goto L13 :: bool
L13:
    r32 = 2
    r33 = r1 == r32 :: int
    if r33 goto L7 else goto L14 :: bool
L14:
    raise StopIteration
    unreachable
def basic_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: basic_gen
    r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = basic_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    return r1
def basic_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: basic_gen
    arg, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    r1 = basic_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    return r1
def basic_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: basic_gen
L0:
    return __mypyc_self__
def basic_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: basic_gen
    type, value, traceback, r0, r1 :: object
L0:
    r0 = builtins.None :: object
    if is_error(value) goto L1 else goto L2
L1:
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L4
L3:
    traceback = r0
L4:
    r1 = basic_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    return r1
def basic():
    r0 :: basic_env
    r1 :: basic_gen
    r2 :: bool
    r3 :: short_int
    r4 :: bool
L0:
    r0 = basic_env()
    r1 = basic_gen()
    r1.__mypyc_env__ = r0; r2 = is_error
    r3 = 0
    r0.__mypyc_next_label__ = r3; r4 = is_error
    return r1

