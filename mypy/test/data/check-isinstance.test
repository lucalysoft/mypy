[case testUnionStrictDefnBasic]
from typing import Union, Undefined

def foo() -> Union(int, str): pass

x = 1 # type: Union(int, str)
x = x + 1
x = foo()
x = x + 1                # E: Unsupported left operand type for + ("Union(int, str)")
if isinstance(x, str):
   x = x + 1             # E: Unsupported operand types for + ("str" and "int")
   x = 1
   x = x + 1

[builtins fixtures/isinstancelist.py]

[case testSubtypeRedefinitionBasic]
from typing import Union, Undefined

class A: pass
class B(A): y = 1

x = A()
x.y        # E: "A" has no attribute "y"
x = B()
x.y        # E: "A" has no attribute "y"
# but it should be ok: x is known to be a B

[builtins fixtures/isinstancelist.py]

[case testIsInstanceBasic]
from typing import Union, Undefined

x = Undefined # type: Union(int, str)

if isinstance(x, str):
    x = x + 1   # E: Unsupported operand types for + ("str" and "int")
    x = x + 'a'
else:
    x = x + 'a' # E: Unsupported operand types for + ("int" and "str")
    x = x + 1
[builtins fixtures/isinstancelist.py]

[case testIsInstanceIndexing]
from typing import Union, Undefined

x = Undefined # type: Union(int, str)
j = [x]

if isinstance(j[0], str):
    j[0] = j[0] + 'a'
    j[0] = j[0] + 1   # E: Unsupported operand types for + ("str" and "int")
else:
    j[0] = j[0] + 'a' # E: Unsupported operand types for + ("int" and "str")
    j[0] = j[0] + 1
[builtins fixtures/isinstancelist.py]

[case testIsInstanceSubClassMember]
from typing import Union, Undefined

class Animal:
    pass

class Dog(Animal):
    paws = 4  # type: Union(int, str)

    def bark(self): pass

class House:
    pet = Undefined(Animal)

h = House()
h.pet = Dog()

while 1:
    if isinstance(h.pet, Dog):
        if isinstance(h.pet.paws, str):
            x = h.pet.paws + 'a'
        y = h.pet.paws + 1   # E: Unsupported left operand type for + ("Union(int, str)")
        z = h.pet.paws + 'a' # E: Unsupported left operand type for + ("Union(int, str)")
        if isinstance(h.pet.paws, str):
            x = h.pet.paws + 'a'
            break
        y = h.pet.paws + 1
        z = h.pet.paws + 'a' # E: Unsupported operand types for + ("int" and "str")

[builtins fixtures/isinstancelist.py]

[case testIsInstanceReturn]
from typing import Union

def foo() -> None:
    x = 1 # type: Union(int, str)
    if isinstance(x, int):
        return
    else:
        pass
    y = x + 'asdad'

foo()
[builtins fixtures/isinstancelist.py]
[case testIsInstanceBadBreak]
from typing import Union, Undefined

def foo() -> None:
    x = Undefined # type: Union(int, str)
    if isinstance(x, int):
        for z in [1,2]:
            break
    else:
        pass
    y = x + 'asdad'    # E: Unsupported left operand type for + ("Union(int, str)")

foo()
[builtins fixtures/isinstancelist.py]
[out]
main: In function "foo":
[case testIsInstanceThreeUnion]
from typing import Union, List, Undefined

x = Undefined # type: Union(int, str, List[int])

while 1:
    if isinstance(x, int):
        x + 1
    elif isinstance(x, str):
        x + 'a'
    else:
        x + [1]
    x + 'a'           # E: Unsupported left operand type for + ("Union(int, str, List[int])")
x + [1]               # E: Unsupported left operand type for + ("Union(int, str, List[int])")

[builtins fixtures/isinstancelist.py]
[case testIsInstanceThreeUnion2]
from typing import Union, List, Undefined

x = Undefined # type: Union(int, str, List[int])

while 1:
    if isinstance(x, int):
        x + 1
        break
    elif isinstance(x, str):
        x + 'a'
        break
    x + [1]
    x + 'a'           # E: Unsupported operand types for + ("list" and "str")
x + [1]               # E: Unsupported left operand type for + ("Union(int, str, List[int])")

[builtins fixtures/isinstancelist.py]

[case testIsInstanceThreeUnion3]
from typing import Union, List

while 1:
    x = 1 # type: Union(int, str, List[int])
    if isinstance(x, int):
        x + 1
        break
    elif isinstance(x, str):
        x + 'a'
        break
    x + [1]           # These lines aren't reached because x was an int
    x + 'a'
x + [1]               # E: Unsupported left operand type for + ("Union(int, str, List[int])")

[builtins fixtures/isinstancelist.py]

[case testRemovingTypeRepeatedly]
from typing import Union

def foo() -> Union(int, str): pass

for i in [1, 2]:
    x = foo()
    x + 'a'                 # E: Unsupported left operand type for + ("Union(int, str)")
    if isinstance(x, int):
        break
    x + 'a'

    x = foo()
    x + 'a'                 # E: Unsupported left operand type for + ("Union(int, str)")
    if isinstance(x, int):
        break
    x + 'a'

    x = foo()
    x + 'a'                 # E: Unsupported left operand type for + ("Union(int, str)")
    if isinstance(x, int):
        break
    x + 'a'

x + 'a'                    # E: Unsupported left operand type for + ("Union(int, str)")
  
[builtins fixtures/isinstancelist.py]



[case testModifyRepeatedly]
from typing import Union

def foo() -> Union(int, str): pass

x = foo()
x + 1     # E: Unsupported left operand type for + ("Union(int, str)")
x + 'a'   # E: Unsupported left operand type for + ("Union(int, str)")

x = 1
x + 1
x + 'a'   # E: Unsupported operand types for + ("int" and "str")

x = 'a'
x + 1     # E: Unsupported operand types for + ("str" and "int")
x + 'a'

x = foo()
x + 1     # E: Unsupported left operand type for + ("Union(int, str)")
x + 'a'   # E: Unsupported left operand type for + ("Union(int, str)")

[builtins fixtures/isinstancelist.py]

[case testModifyLoop]
from typing import Union

def foo() -> Union(int, str): pass

x = foo()
x + 1      # E: Unsupported left operand type for + ("Union(int, str)")
x = 'a'
x + 1      # E: Unsupported operand types for + ("str" and "int")
x = 1
x + 1

while 1:
      x + 1    # SHOULD BE E: moo
      x = 'a'


[builtins fixtures/isinstancelist.py]

[case testCastIsinstance]
from typing import Union

def foo() -> Union(int, str): pass

x = foo()
y = 1 # type: int

if isinstance(x, str):
    x = y
x + 1
x + 'a'   # E: Unsupported operand types for + ("int" and "str")

[builtins fixtures/isinstancelist.py]


[case testUnreachableCode]
x = 1 # type: int

while 1:
    x = 'a'           # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    break
    x = 'a'           # Note: no error because unreachable code
[builtins fixtures/isinstancelist.py]

