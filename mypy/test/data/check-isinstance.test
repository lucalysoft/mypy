[case testIsInstanceIndexing]
from typing import Union

x = 1 # type: Union(int, str)
j = [x]

if isinstance(j[0], str):
    j[0] = j[0] + 'a'
    j[0] = j[0] + 1   # E: Unsupported operand types for + ("str" and "int")
else:
    j[0] = j[0] + 'a' # E: Unsupported operand types for + ("int" and "str")
    j[0] = j[0] + 1
[builtins fixtures/isinstancelist.py]

[case testIsInstanceSubClassMember]
from typing import Union, Undefined

class Animal:
    pass

class Dog(Animal):
    paws = 4  # type: Union(int, str)

    def bark(self): pass

class House:
    pet = Undefined(Animal)

h = House()
h.pet = Dog()

while 1:
    if isinstance(h.pet, Dog):
        if isinstance(h.pet.paws, str):
            x = h.pet.paws + 'a'
        y = h.pet.paws + 1   # E: Unsupported left operand type for + ("Union(int, str)")
        z = h.pet.paws + 'a' # E: Unsupported left operand type for + ("Union(int, str)")
        if isinstance(h.pet.paws, str):
            x = h.pet.paws + 'a'
            break
        y = h.pet.paws + 1
        z = h.pet.paws + 'a' # E: Unsupported operand types for + ("int" and "str")

[builtins fixtures/isinstancelist.py]

[case testIsInstanceReturn]
from typing import Union

def foo() -> None:
    x = 1 # type: Union(int, str)
    if isinstance(x, int):
        return
    else:
        pass
    y = x + 'asdad'

foo()
[builtins fixtures/isinstancelist.py]
[case testIsInstanceBadBreak]
from typing import Union

def foo() -> None:
    x = 1 # type: Union(int, str)
    if isinstance(x, int):
        for z in [1,2]:
            break
    else:
        pass
    y = x + 'asdad'    # E: Unsupported left operand type for + ("Union(int, str)")

foo()
[builtins fixtures/isinstancelist.py]
[out]
main: In function "foo":
[case testIsInstanceThreeUnion]
from typing import Union, List

x = 1 # type: Union(int, str, List[int])

while 1:
    if isinstance(x, int):
        x + 1
    elif isinstance(x, str):
        x + 'a'
    else:
        x + [1]
    x + 'a'           # E: Unsupported left operand type for + ("Union(int, str, List[int])")
x + [1]               # E: Unsupported left operand type for + ("Union(int, str, List[int])")

[builtins fixtures/isinstancelist.py]
[case testIsInstanceThreeUnion2]
from typing import Union, List

x = 1 # type: Union(int, str, List[int])

while 1:
    if isinstance(x, int):
        x + 1
        break
    elif isinstance(x, str):
        x + 'a'
        break
    x + [1]
    x + 'a'           # E: Unsupported operand types for + ("list" and "str")
x + [1]               # E: Unsupported left operand type for + ("Union(int, str, List[int])")

[builtins fixtures/isinstancelist.py]

[case testRemovingTypeRepeatedly]
from typing import Union

def foo() -> Union(int, str): pass

for i in [1, 2]:
    x = foo()
    if isinstance(x, int):
        break
    x + 'a'

    x = foo()
    if isinstance(x, int):
        break
    x + 'a'

    x = foo()
    if isinstance(x, int):
        break
    x + 'a'

x + 'a'                    # E: moo

[builtins fixtures/isinstancelist.py]


[case testUnreachableCode]
x = 1 # type: int

while 1:
    x = 'a'           # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    break
    x = 'a'           # Note: no error because unreachable code
[builtins fixtures/isinstancelist.py]

