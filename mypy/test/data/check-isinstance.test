[case testSingleMultiAssignment-skip]

x = 'a'
(x, ) = ('a',)

[case testUnionMultiAssignment-skip]
from typing import Union, Undefined

x = Undefined # type: Union[int, str]
x = 1
x = 'a'
x + 1    # E: Unsupported operand types for + ("str" and "int")
x = 1
(x, y) = ('a', 1)
x + 1    # E: Unsupported operand types for + ("str" and "int")

[builtins fixtures/isinstancelist.py]

[case testUnionIfZigzag-skip]
from typing import Union

def f(x: Union[int, str]) -> None:
    x = 1
    if x:
        x = 'a'
        x = 1
    x + 1          # My code fails
[builtins fixtures/isinstancelist.py]


[case testComplicatedBlocks-skip]
from typing import Union

def foo() -> Union[int, str]: pass

def bar() -> None:
    x = foo()
    if isinstance(x, int):
        return
    while 1:
        x + 'a'
        while 1:
            x = foo()
            if 1:
                return
            x = 'a'
    x + 'a'

    x = foo()
    if isinstance(x, int):
        return
    while 1:
        x + 'a'             # E: Unsupported operand types for + (likely involving Union)
        while 1:
            x + 'a'         # E: Unsupported operand types for + (likely involving Union)
            x = foo()
            if 1:
                continue
            x = 'a'
        x = 'a'
    x + 'a'
[builtins fixtures/isinstancelist.py]
[out]
main: In function "bar":

[case testUnionTryExcept-skip]

class A: y = A()
class B(A): z = 1

x = A()
try:
    x.z # E: "A" has no attribute "z"
    x = B()
    x.z
except:
    x.z # E: "A" has no attribute "z"
    x = B()
    x.z
x.z     # My code fails


[case testUnionListIsinstance]

from typing import Union, List

class A: y = A()
class B(A): z = C()
    
class C: pass
class D(C): d = 1

    
def f(x: Union[List[int], List[str], int]) -> None:
    if isinstance(x, list):
        a = x[0]
        if isinstance(a, int):
            a + 1
            a + 'x' # E: Unsupported operand types for + ("int" and "str")

        # type of a?
        x + 1 # E: Unsupported operand types for + (likely involving Union)
    else:
        x[0] # E: Value of type "int" is not indexable
        x + 1
    x[0] # E: Value of type "int" is not indexable
    x + 1 # E: Unsupported operand types for + (likely involving Union)
[builtins fixtures/isinstancelist.py]
[out]
main: In function "f":

[case testUnionStrictDefnBasic]
from typing import Union, Undefined

def foo() -> Union[int, str]: pass

x = 1 # type: Union[int, str]
x = x + 1
x = foo()
x = x + 1                # E: Unsupported operand types for + (likely involving Union)
if isinstance(x, str):
   x = x + 1             # E: Unsupported operand types for + ("str" and "int")
   x = 1
   x = x + 1

[builtins fixtures/isinstancelist.py]

[case testSubtypeRedefinitionBasic]
from typing import Union, Undefined

class A: pass
class B(A): y = 1

x = A()
x.y        # E: "A" has no attribute "y"
x = B()
x.y        # OK: x is known to be a B

[builtins fixtures/isinstancelist.py]

[case testIsInstanceBasic]
from typing import Union, Undefined

x = Undefined # type: Union[int, str]

if isinstance(x, str):
    x = x + 1   # E: Unsupported operand types for + ("str" and "int")
    x = x + 'a'
else:
    x = x + 'a' # E: Unsupported operand types for + ("int" and "str")
    x = x + 1
[builtins fixtures/isinstancelist.py]

[case testIsInstanceIndexing]
from typing import Union, Undefined

x = Undefined # type: Union[int, str]
j = [x]

if isinstance(j[0], str):
    j[0] = j[0] + 'a'
    j[0] = j[0] + 1   # E: Unsupported operand types for + ("str" and "int")
else:
    j[0] = j[0] + 'a' # E: Unsupported operand types for + ("int" and "str")
    j[0] = j[0] + 1
[builtins fixtures/isinstancelist.py]

[case testIsInstanceSubClassMember]
from typing import Union, Undefined

class Animal:
    pass

class Dog(Animal):
    paws = 4  # type: Union[int, str]

    def bark(self): pass

class House:
    pet = Undefined(Animal)

h = House()
h.pet = Dog()

while 1:
    if isinstance(h.pet, Dog):
        if isinstance(h.pet.paws, str):
            x = h.pet.paws + 'a'
        y = h.pet.paws + 1   # E: Unsupported operand types for + (likely involving Union)
        z = h.pet.paws + 'a' # E: Unsupported operand types for + (likely involving Union)
        if isinstance(h.pet.paws, str):
            x = h.pet.paws + 'a'
            break
        y = h.pet.paws + 1
        z = h.pet.paws + 'a' # E: Unsupported operand types for + ("int" and "str")

[builtins fixtures/isinstancelist.py]

[case testIsInstanceReturn]
from typing import Union

def foo() -> None:
    x = 1 # type: Union[int, str]
    if isinstance(x, int):
        return
    else:
        pass
    y = x + 'asdad'

foo()
[builtins fixtures/isinstancelist.py]
[case testIsInstanceBadBreak]
from typing import Union, Undefined

def foo() -> None:
    x = Undefined # type: Union[int, str]
    if isinstance(x, int):
        for z in [1,2]:
            break
    else:
        pass
    y = x + 'asdad'    # E: Unsupported operand types for + (likely involving Union)

foo()
[builtins fixtures/isinstancelist.py]
[out]
main: In function "foo":
[case testIsInstanceThreeUnion]
from typing import Union, List, Undefined

x = Undefined # type: Union[int, str, List[int]]

while 1:
    if isinstance(x, int):
        x + 1
    elif isinstance(x, str):
        x + 'a'
    else:
        x + [1]
    x + 'a'           # E: Unsupported operand types for + (likely involving Union)
x + [1]               # E: Unsupported operand types for + (likely involving Union)

[builtins fixtures/isinstancelist.py]
[case testIsInstanceThreeUnion2]
from typing import Union, List, Undefined

x = Undefined # type: Union[int, str, List[int]]

while 1:
    if isinstance(x, int):
        x + 1
        break
    elif isinstance(x, str):
        x + 'a'
        break
    x + [1]
    x + 'a'           # E: Unsupported operand types for + ("list" and "str")
x + [1]               # E: Unsupported operand types for + (likely involving Union)

[builtins fixtures/isinstancelist.py]

[case testIsInstanceThreeUnion3]
from typing import Union, List

while 1:
    x = 1 # type: Union[int, str, List[int]]
    if isinstance(x, int):
        x + 1
        break
    elif isinstance(x, str):
        x + 'a'
        break
    x + [1]           # These lines aren't reached because x was an int
    x + 'a'
x + [1]               # E: Unsupported operand types for + (likely involving Union)

[builtins fixtures/isinstancelist.py]

[case testRemovingTypeRepeatedly]
from typing import Union

def foo() -> Union[int, str]: pass

for i in [1, 2]:
    x = foo()
    x + 'a'                 # E: Unsupported operand types for + (likely involving Union)
    if isinstance(x, int):
        break
    x + 'a'

    x = foo()
    x + 'a'                 # E: Unsupported operand types for + (likely involving Union)
    if isinstance(x, int):
        break
    x + 'a'

    x = foo()
    x + 'a'                 # E: Unsupported operand types for + (likely involving Union)
    if isinstance(x, int):
        break
    x + 'a'

x + 'a'                    # E: Unsupported operand types for + (likely involving Union)
  
[builtins fixtures/isinstancelist.py]



[case testModifyRepeatedly]
from typing import Union

def foo() -> Union[int, str]: pass

x = foo()
x + 1     # E: Unsupported operand types for + (likely involving Union)
x + 'a'   # E: Unsupported operand types for + (likely involving Union)

x = 1
x + 1
x + 'a'   # E: Unsupported operand types for + ("int" and "str")

x = 'a'
x + 1     # E: Unsupported operand types for + ("str" and "int")
x + 'a'

x = foo()
x + 1     # E: Unsupported operand types for + (likely involving Union)
x + 'a'   # E: Unsupported operand types for + (likely involving Union)

[builtins fixtures/isinstancelist.py]

[case testModifyLoop]
from typing import Union

def foo() -> Union[int, str]: pass

x = foo()
x + 1      # E: Unsupported operand types for + (likely involving Union)
x = 'a'
x + 1      # E: Unsupported operand types for + ("str" and "int")
x = 1
x + 1

while 1:
      x + 1    # E: Unsupported operand types for + (likely involving Union)
      x = 'a'
[builtins fixtures/isinstancelist.py]


[case testModifyLoopLong]
from typing import Union

class A: a = 1

def foo() -> Union[int, str, A]: pass

def bar() -> None:
    x = foo()
    x + 1  # E: Unsupported left operand type for + (some union)
    if isinstance(x, A):
       x.a
    else:
       if isinstance(x, int):
          x + 1
          x + 'a'  # E: Unsupported operand types for + ("int" and "str")
       else:
          x + 'a'
          x.a      # E: "str" has no attribute "a"
       x = A()

    if isinstance(x, str):
       x + 'a'
    else:
       while 1:
          if isinstance(x, int):
             x + 1
          else:
             x.a
          break
       while 1:
          if isinstance(x, int):
             x + 1
          else:
             x.a
          continue

       #for i in [1]:
       while 1:
          if isinstance(x, int):
             x + 1
          else:
             x.a     # E: Some element of union has no attribute "a"
          x = 'a'

[builtins fixtures/isinstancelist.py]
[out]
main: In function "bar":

[case testCastIsinstance]
from typing import Union

def foo() -> Union[int, str]: pass

x = foo()
y = 1 # type: int

if isinstance(x, str):
    x = y
x + 1
x + 'a'   # E: Unsupported operand types for + ("int" and "str")

[builtins fixtures/isinstancelist.py]


[case testUnreachableCode]
x = 1 # type: int

while 1:
    x = 'a'           # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    break
    x = 'a'           # Note: no error because unreachable code
[builtins fixtures/isinstancelist.py]

