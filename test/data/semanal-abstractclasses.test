[case testAbstractMethods]
from abc import abstractmethod, ABCMeta
import typing

class A(metaclass=ABCMeta):
  @abstractmethod
  def g(self) -> 'A': pass
  @abstractmethod
  def f(self) -> 'A': return self
[out]
MypyFile:1(
  ImportFrom:1(abc, [abstractmethod : abstractmethod, ABCMeta : ABCMeta])
  Import:2(typing : typing)
  TypeDef:4(
    A
    Metaclass(ABCMeta)
    Decorator:5(
      Var(g)
      FuncDef:6(
        g
        Args(
          Var(self))
        def (self: __main__.A) -> __main__.A
        Abstract
        Block:6(
          PassStmt:6())))
    Decorator:7(
      Var(f)
      FuncDef:8(
        f
        Args(
          Var(self))
        def (self: __main__.A) -> __main__.A
        Abstract
        Block:8(
          ReturnStmt:8(
            NameExpr(self [l])))))))

[case testClassInheritingTwoAbstractClasses]
from abc import abstractmethod, ABCMeta
import typing

class A(metaclass=ABCMeta): pass
class B(metaclass=ABCMeta): pass
class C(A, B): pass
[out]
MypyFile:1(
  ImportFrom:1(abc, [abstractmethod : abstractmethod, ABCMeta : ABCMeta])
  Import:2(typing : typing)
  TypeDef:4(
    A
    Metaclass(ABCMeta)
    PassStmt:4())
  TypeDef:5(
    B
    Metaclass(ABCMeta)
    PassStmt:5())
  TypeDef:6(
    C
    BaseType(
      __main__.A
      __main__.B)
    PassStmt:6()))
