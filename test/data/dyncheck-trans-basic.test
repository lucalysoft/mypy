-- Test cases for runtime (dynamic) checking transformation.
--
-- Each test case consists of at least two sections.
-- The first section contains [case NAME] followed by the input code, while
-- the second section contains [out] followed by the output from the
-- transformation.

-- Note that the test cases use a pretty-printed output syntax that is not
-- valid mypy code.


-- Empty method transformation, no inheritance
-- -------------------------------------------


[case testEmptyClass]
import typing
class A: pass
class B: pass
[out]
class A:
    pass
any A*():
    return A()
class B:
    pass
any B*():
    return B()

[case testSimpleMethod]
import typing
class A:
    def __init__(self) -> None:
        pass
    
    def f(self) -> int:
        pass
[out]
class A:
    void __init__(A self):
        pass
    int f(A self):
        pass
    any f*(any self):
        return {any <= int {A self}.f()}
any A*():
    return A()

[case testMethodWithArguments]
import typing
class A:
    def __init__(self) -> None:
        pass
    
    def f(self, a: 'A') -> None:
        pass
[out]
class A:
    void __init__(A self):
        pass
    void f(A self, A a):
        pass
    any f*(any self, any a):
        {A self}.f({A a})
any A*():
    return A()

[case testMethodWithDynamicTypesInArguments]
from typing import Any
class A:
    def f(self, a: Any, b: Any) -> 'A':
        pass
[out]
class A:
    A f(A self, any a, any b):
        pass
    any f*(any self, any a, any b):
        return {A self}.f(a, b)
any A*():
    return A()

[case testMethodWithDynamicReturnType]
from typing import Any
class A:
    def f(self, a: 'A') -> Any:
        pass
[out]
class A:
    any f(A self, A a):
        pass
    any f*(any self, any a):
        return {A self}.f({A a})
any A*():
    return A()


-- Empty methods with inheritance
-- ------------------------------


[case testOverridingStaticWithDynamic]
from typing import Any
class A:
    def f(self, a: float) -> int:
        pass
class B(A):
    def f(self, a: Any) -> Any:
        pass
[out]
class A:
    int f(A self, float a):
        pass
    any f*(any self, any a):
        return {any <= int {A self}.f({float a})}
any A*():
    return A()
class B(A):
    any f`B(B self, any a):
        pass
    int f(A self, float a):
        return {int {B self}.f`B({any <= float a})}
    any f*(any self, any a):
        return {B self}.f`B(a)
any B*():
    return B()

[case testOverridingDynamicWithStatic]
from typing import Any
class A:
    def f(self, a: Any) -> Any:
        pass
class B(A):
    def f(self, a: A) -> int:
        pass
[out]
class A:
    any f(A self, any a):
        pass
    any f*(any self, any a):
        return {A self}.f(a)
...
class B(A):
    int f`B(B self, A a):
        pass
    any f(A self, any a):
        return {any <= int {B self}.f`B({A a})}
    any f*(any self, any a):
        return {any <= int {B self}.f`B({A a})}
...

[case testNewMethodInSubclass]
import typing
class A:
    def f(self, a: 'A') -> 'B':
        pass
class B(A):
    def g(self, b: 'B') -> A:
        pass
[out]
class A:
    B f(A self, A a):
        pass
    any f*(any self, any a):
        return {A self}.f({A a})
...
class B(A):
    A g(B self, B b):
        pass
    any g*(any self, any b):
        return {B self}.g({B b})
...

[case testOverridingMethodInGrandparent]
from typing import Any
class A:
    def f(self, a: int) -> 'B':
        pass
class B(A): pass
class C(B):
    def f(self, a: Any) -> Any:
        pass
[out]
...
class B(A):
    pass
...
class C(B):
    any f`C(C self, any a):
        pass
    B f(A self, int a):
        return {B {C self}.f`C({any <= int a})}
    any f*(any self, any a):
        return {C self}.f`C(a)
...

[case testOverridingMethodTwice]
from typing import Any
class A:
    def f(self, a: int) -> float:
        pass
class B(A):
    def f(self, a: Any) -> float:
        pass
class C(B):
    def f(self, a: int) -> Any:
        pass
[out]
...
class B(A):
    float f`B(B self, any a):
        pass
    float f(A self, int a):
        return {B self}.f`B({any <= int a})
    any f*(any self, any a):
        return {any <= float {B self}.f`B(a)}
...
class C(B):
    any f`C(C self, int a):
        pass
    float f`B(B self, any a):
        return {float {C self}.f`C({int a})}
    any f*(any self, any a):
        return {C self}.f`C({int a})
...

[case testOverridingWithSameSig]
import typing
class A:
    def f(self, a: 'A') -> 'B':
        pass
class B(A):
    def f(self, a: A) -> 'B':
        return None
[out]
...
class B(A):
    B f(B self, A a):
        return None
any B*():
...

[case testOverridingDynamicWithDynamic]
from typing import Any
class A:
    def f(self, a: Any) -> Any:
        pass
class B(A):
    def f(self, a: Any) -> Any:
        return None
[out]
...
class B(A):
    any f(B self, any a):
        return None
any B*():
...

[case testOverridingFirstWithDynamicAndThenWithSameSig]
from typing import Any
class A:
    def f(self, a: int) -> None:
        self.f(a)
class B(A):
    def f(self, a: Any) -> None:
        self.f(a)
class C(B):
    def f(self, a: Any) -> None:
        self.f(a)
[out]
...
class B(A):
    void f`B(B self, any a):
        self.f`B(a)
    void f(A self, int a):
        {B self}.f`B({any <= int a})
    any f*(any self, any a):
        {B self}.f`B(a)
...
class C(B):
    void f`B(C self, any a):
        self.f`B(a)
any C*():
...


-- Method calls
-- ------------


[case testCallStaticallyTypedMethod]
import typing
class A:
    def f(self, b: 'B') -> 'A':
        return b.g()
class B:
    def g(self) -> A:
        pass
[out]
class A:
    A f(A self, B b):
        return b.g()
...

[case testCallDynamicallyTypedMethod]
from typing import Any
class A:
    def f(self, b: Any) -> Any:
        return b.g()
class B:
    def g(self) -> A:
        pass
[out]
class A:
    any f(A self, any b):
        return b.g*()
...

[case testStaticCallWithArguments]
from typing import Any
class A:
    def f(self, b: 'B') -> 'A':
        return b.g(b, 1)
class B:
    def g(self, b: 'B', d: Any) -> A:
        pass
[out]
class A:
    A f(A self, B b):
        return b.g(b, {any <= int 1})
...

[case testDynamicCallWithArguments]
from typing import Any
class A:
    def f(self, d: Any, i: int) -> 'A':
        return d.g(d, i)
[out]
class A:
    A f(A self, any d, int i):
        return {A d.g*(d, {any <= int i})}
...

[case testMethodCallWithInheritance]
import typing
class A:
    def f1(self, b: 'B') -> 'A':
        return b.f1(b)
    def f2(self, b: 'B', a: 'A') -> 'B':
        return b.g(a)
class B(A):
    def g(self, a: A) -> 'B':
        pass
[out]
class A:
    A f1(A self, B b):
        return b.f1(b)
...
    B f2(A self, B b, A a):
        return b.g(a)
...

[case testMethodCallWithOverride]
from typing import Any
class A:
    def f(self, b: 'B') -> 'A':
        return b.f(b)
    def f2(self, a: 'A', b: 'B') -> 'A':
        return a.f(b)
class B(A):
    def f(self, b: 'B') -> Any:
        pass
[out]
class A:
    A f(A self, B b):
        return {A b.f`B(b)}
...
    A f2(A self, A a, B b):
        return a.f(b)
...

[case testNestedMethodCalls]
from typing import Any
class A:
    def f(self, a: 'A') -> Any:
        return a.g(a.g(1))
    def g(self, a: Any) -> int:
        pass
[out]
class A:
    any f(A self, A a):
        return {any <= int a.g({any <= int a.g({any <= int 1})})}
...

[case testMethodCallViaSelf]
from typing import Any
class A:
    def f(self, a: int) -> Any:
        return self.g(a)
    def g(self, a: Any) -> int:
        pass
[out]
class A:
    any f(A self, int a):
        return {any <= int self.g({any <= int a})}
...


-- Statements
-- ----------


[case testReturnStatement1]
from typing import Any
class A:
    def f(self, b: 'B') -> Any:
        return b.g()
class B:
    def g(self) -> A:
        pass
[out]
class A:
    any f(A self, B b):
        return b.g()
    any f*(any self, any b):
        return {A self}.f({B b})
...

[case testReturnStatement2]
from typing import Any
class A:
    def f(self, b: 'B') -> 'A':
        return b.g()
class B:
    def g(self) -> Any:
        pass
[out]
class A:
    A f(A self, B b):
        return {A b.g()}
    any f*(any self, any b):
        return {A self}.f({B b})
...

[case testIfStatement]
from typing import Undefined, Any
b = False
d = Undefined # type: Any
if b:
    d = 1
elif d:
    d = 2
else:
    d = 3
[builtins fixtures/ops.py]
[out]
...
if b:
    d = {any <= int 1}
elif d:
    d = {any <= int 2}
else:
    d = {any <= int 3}

[case testWhileStatement]
from typing import Undefined, Any
b = False
d = Undefined # type: Any
while b:
    while d:
        d = 1
[builtins fixtures/ops.py]
[out]
...
while b:
    while d:
        d = {any <= int 1}


-- Cast insertion (or non-insertion) in specific cases
-- ---------------------------------------------------


[case testOmitSubtypeToSupertypeCast]
import typing
class A:
    def f(self, b: 'B') -> 'A':
        return b
class B(A): pass
[out]
class A:
    A f(A self, B b):
        return b
...


-- __init__ and object construction
-- --------------------------------


[case testConstructInstanceWithPreciseTypes]
import typing
class A:
    def __init__(self, b: 'B') -> None:
        pass
    
    def f(self, b: 'B') -> 'A':
        return A(b)
class B: pass
[out]
class A:
    void __init__(A self, B b):
        pass
    A f(A self, B b):
        return A(b)
...
any A*(any b):
    return A({B b})
...

[case testClassWrapperWithTwoArguments]
from typing import Any
class A:
    def __init__(self, a: Any, i: int) -> None: pass
[out]
...
any A*(any a, any i):
    return A(a, {int i})

[case testCreateInstanceWithTrivialReturnTypeCoercion]
from typing import Any
class A:
    def f(self) -> Any:
        return A()
[out]
class A:
    any f(A self):
        return A()
...

[case testCreateInstanceWithArgumentCasts]
from typing import Any
class A:
    def f(self, b: int, d: Any) -> 'B':
        return B(b, d)
class B:
    def __init__(self, d: Any, a: A) -> None:
        pass
[out]
class A:
    B f(A self, int b, any d):
        return B({any <= int b}, {A d})
...


-- Self expressions
-- ----------------


[case testSelf]
from typing import Any
class A:
    def f(self, a: Any) -> None:
        self.f(self)
[out]
class A:
    void f(A self, any a):
        self.f(self)
...


-- Data attributes
-- ---------------


[case testDataAttributeAccessors]
import typing
class A:
    i = 0
[out]
class A:
    int i
    int $i(A self):
        return self.i!
    void set$i(A self, int i):
        self.i! = i
    any $i*(A self):
        return {any <= int self.i!}
    void set$i*(A self, any i):
        self.i! = {int i}
any A*():
    return A()

[case testMemberVariableAccessViaInstanceType]
from typing import Undefined, Any
class A:
    a = 0
    d = Undefined # type: Any
    def f(self) -> int:
        return self.d
    def g(self) -> Any:
        return self.a
[out]
class A:
...
    int f(A self):
        return {int self.d}
...
    any g(A self):
        return {any <= int self.a}
...

[case testMemberVariableAssignmentViaInstanceType]
from typing import Undefined, Any
class A:
    a = 0
    d = Undefined # type: Any
    def __init__(self, d: Any) -> None:
        self.a = d
        self.d = d
[out]
...
    void __init__(A self, any d):
        self.a = {int d}
        self.d = d
...

[case testMemberVariableAccessViaAny]
from typing import Any
class A:
    def f(self, d: Any) -> 'A':
        return d.x
[out]
class A:
    A f(A self, any d):
        return {A d.x*}
...

[case testMemberVariableAssignmentViaDynamic]
from typing import Undefined, Any
d = Undefined # type: Any
d.x = 1
[out]
...
d.x* = {any <= int 1}

[case testDataAttributeWithImplicitDefinition]
import typing
class A:
    def __init__(self) -> None:
        self.x = 0
[out]
...
    void __init__(A self):
        self.x = 0
...
    int $x(A self):
        return self.x!
    void set$x(A self, int x):
        self.x! = x
    any $x*(A self):
...
    void set$x*(A self, any x):
...


-- Casts
-- -----


[case testCast]
from typing import cast
class A:
    def f(self, a: 'A') -> 'B':
        return cast('B', a)
class B(A): pass
[out]
class A:
    B f(A self, A a):
        return (B)a
...

[case testDynamicCast]
from typing import Any
class A:
    def f(self, a: int) -> float:
        return Any(a)
[out]
class A:
    float f(A self, int a):
        return {float (any){any <= int a}}
...

[case testNestedCasts]
from typing import cast, Any
cast(int, Any(1))
[out]
(int)(any){any <= int 1}


-- Global expressions
-- ------------------


[case testGlobalExpression]
from typing import Any
class A:
    def f(self, a: Any) -> None:
        pass

A().f(1)
[out]
...
A().f({any <= int 1})


-- Void type
-- ---------


[case testVoidReturn]
from typing import Any
class A:
    def f(self, b: Any) -> None:
        pass
class B(A):
    def f(self, b: 'B') -> None:
        pass
[out]
class A:
    void f(A self, any b):
        pass
    any f*(any self, any b):
        {A self}.f(b)
any A*():
    return A()
class B(A):
    void f`B(B self, B b):
        pass
    void f(A self, any b):
        {B self}.f`B({B b})
    any f*(any self, any b):
        {B self}.f`B({B b})
any B*():
    return B()


-- Function definition and call
-- ----------------------------


[case testFunctionDefinitionAndCall]
from typing import Any, Undefined
def f(a: int) -> int:
    return Any(1)
d = Undefined # type: Any
d = f(Any(1))
[out]
int f(int a):
    return {int (any){any <= int 1}}
any d
d = {any <= int f({int (any){any <= int 1}})}


-- Assignment and initialization
-- -----------------------------


[case testAssignmentToGlobal]
from typing import Undefined, Any
a = 0
d = Undefined # type: Any
a = a
a = d
d = a
[out]
int a
any d
a = a
a = {int d}
d = {any <= int a}

[case testGlobalInitialization]
from typing import Undefined, Any
a = 0
d = Undefined # type: Any
dd = a # type: Any
aa = a # type: int
[out]
int a
any d
any dd = {any <= int a}
int aa = a

[case testLocalVariableAssignmentAndInit]
from typing import Any
def f() -> None:
    a = 0
    d = a # type: Any
    aa = a # type: int
    a = a
    d = a
[out]
void f():
    int a
    any d = {any <= int a}
    int aa = a
    a = a
    d = {any <= int a}

[case testMemberInitialization]
from typing import Any
class A:
    a = 0
    d = 1 # type: Any
    b = 1 # type: int
    
    def __init__(self, a: int) -> None:
        self.a = a
[out]
class A:
...
    any d = {any <= int 1}
...
    int b = 1
...


-- None
-- ----


[case testInitializationToNone]
from typing import Any
a = None # type: object
d = None # type: Any
[out]
object a = None
any d = None

[case testNoneAsFunctionArgument]
import typing
def f(a: 'A') -> None:
    pass
f(None)
class A: pass
[out]
...
f(None)
...


-- Displaying debugging information
-- --------------------------------


[case testSimplePrint]
import typing
# The arguments to debugging functions are not coerced.
__print('hello')
[out]
__print('hello')

[case testComplexPrint]
import typing
def f(a): pass
a = 0
__print(a, f(a))
[out]
...
int a
__print(a, f({any <= int a}))


-- Coercions from primitive types
-- ------------------------------


[case testCoercionFromPrimitiveToObject]
from typing import Undefined
o = Undefined # type: object
i = 0
f = 0.0
a = Undefined # type: A
o = i
o = f
o = a
i = i
class A: pass
[out]
...
A a
o = {object <= int i}
o = {object <= float f}
o = a
i = i
...


-- Primitive operations
-- --------------------


[case testIntLiterals]
from typing import Any
a = 1 # type: int
d = 1 # type: Any
[out]
int a = 1
any d = {any <= int 1}

[case testIntArithmetic]
from typing import Undefined, Any
i = 0
d = Undefined # type: Any
i = 1 + 2
i = (1 - 2) * 2
i = 1 % 2
i = 1 // 2
i = -i
d = 1 + d
d = 1 - d
d = 1 * d
d = 1 % d
d = 1 // d
d = -d + d - d * d
d = d + 1
d = d - 1
d = d * 1
d = d % d
d = d // d
[builtins fixtures/ops.py]
[out]
...
i = 1 + 2
i = (1 - 2) * 2
i = 1 % 2
i = 1 // 2
i = -i
d = {any <= int 1 + {int d}}
d = {any <= int 1 - {int d}}
d = {any <= int 1 * {int d}}
d = {any <= int 1 % {int d}}
d = {any <= int 1 // {int d}}
d = -d + d - d * d
d = d + {any <= int 1}
d = d - {any <= int 1}
d = d * {any <= int 1}
d = d % d
d = d // d

[case testBinaryOperationOperands]
from typing import Undefined, Any
d = Undefined # type: Any
i = 0
i = d.g() + d.f()
i = d.g() * d.f()
i = i + d.f()
i = -d.g()
[builtins fixtures/ops.py]
[out]
...
i = {int d.g*() + d.f*()}
i = {int d.g*() * d.f*()}
i = i + {int d.f*()}
i = {int -d.g*()}

[case testBools]
from typing import Undefined, Any
b = False
d = Undefined # type: Any
b = True
b = False
d = True
d = False
b = b and b
d = b or b
b = not b
d = not b
b = b and d
d = b or d
b = d and b
d = d or b
b = d and d
d = d or d
b = not d
[builtins fixtures/ops.py]
[out]
bool b
any d
b = True
b = False
d = {any <= bool True}
d = {any <= bool False}
b = b and b
d = {any <= bool b or b}
b = not b
d = {any <= bool not b}
b = {bool {any <= bool b} and d}
d = {any <= bool b} or d
b = {bool d and {any <= bool b}}
d = d or {any <= bool b}
b = {bool d and d}
d = d or d
b = not d

[case testIntComparisons]
from typing import Undefined, Any
i = 0
b = False
d = Undefined # type: Any
b = 1 == 2
d = 1 != 2
b = 1 < 2
b = 1 <= 2
b = 1 > 2
b = 1 >= 2
b = d == d
d = d == d
b = d != 1
b = 1 < d
d = 1 > d
[builtins fixtures/ops.py]
[out]
...
b = 1 == {object <= int 2}
d = {any <= bool 1 != {object <= int 2}}
b = 1 < 2
b = 1 <= 2
b = 1 > 2
b = 1 >= 2
b = {bool d == d}
d = d == d
b = {bool d != {any <= int 1}}
b = 1 < {int d}
d = {any <= bool 1 > {int d}}

[case testNoneComparison]
from typing import Undefined
b = False
c = Undefined # type: C
b = b is None
b = c is not None
b = b == None
b = c == None
class C: pass
[builtins fixtures/ops.py]
[out]
...
b = b is None
b = c is not None
b = b == None
b = c == None
...

[case testStrLiterals]
import typing
s = 'foo' # type: str
__print(s)
__print('bar')
[out]
str s = 'foo'
__print(s)
__print('bar')


-- Type inference
-- --------------


[case testSimpleTypeInference]
from typing import Any
y = 1
a = y # type: Any
[out]
y = 1
any a = {any <= int y}


-- Implicit any types
-- ------------------


[case testImplicitFunctionSig]
import typing
def f(a, b):
    pass
def g() -> None:
    i = f(1, 2) # type: int
[out]
any f(any a, any b):
    pass
void g():
    int i = {int f({any <= int 1}, {any <= int 2})}

[case testImplicitMethodSig]
import typing
class A:
    def f(self, a):
        pass
    def g(self) -> None:
        i = self.f(1) # type: int
        j = self.f(1) # type: int
[out]
class A:
    any f(any self, any a):
        pass
    any f*(any self, any a):
        return self.f(a)
    void g(A self):
        int i = {int self.f({any <= int 1})}
        int j = {int self.f({any <= int 1})}
    any g*(any self):
        {A self}.g()
...

[case testImplicitMethodSigAndOverride]
import typing
class A:
    def f(self, a):
        pass
    def g(self, a: 'A') -> 'A':
        pass
class B(A):
    def f(self, a):
        pass
    def g(self, a):
        pass
[out]
...
class B(A):
    any f(any self, any a):
        pass
    any g`B(any self, any a):
        pass
    A g(A self, A a):
        return {A self.g`B(a)}
    any g*(any self, any a):
        return self.g`B(a)
...

[case testDynamicallyTypedFunctionBody]
from typing import Undefined
def f(x):
    y = 1
    i + y
    o + o
    x = g(o)
def g(x: int) -> int:
    pass
i = 0
o = Undefined # type: object
[out]
any f(any x):
    y = {any <= int 1}
    {any <= int i} + y
    {any o} + o
    x = {any <= int g({int o})}
...

[case testDynamicallyTypedMethodBody]
import typing
class A:
    i = 0
    def f(self, x):
        x = self.g(x)
        x = self.z()
        x = self.i
        x.y()
    def g(self, x: int) -> int:
        pass
[out]
class A:
...
    any f(any self, any x):
        x = self.g*(x)
        x = self.z*()
        x = self.i*
        x.y*()
...


-- Operator overloading
-- --------------------


[case testBinaryOperatorOverloading]
from typing import Undefined, Any
class A:
    def __add__(self, x: 'A') -> int: pass
x = Undefined # type: Any
a = Undefined # type: A
x = a + x
[out]
...
A a
x = {any <= int a + {A x}}

[case testBinaryOperatorOverloading2]
from typing import Undefined, Any
class A:
    def __mul__(self, x: int) -> 'A': pass
x = Undefined # type: Any
a = Undefined # type: A
x = a * x
[out]
...
A a
x = a * {int x}

[case testIndexedGet]
from typing import Undefined, Any
class A:
    def __getitem__(self, x: 'A') -> int: pass
x = Undefined # type: Any
a = Undefined # type: A
x = a[x]
[out]
...
A a
x = {any <= int a[{A x}]}

[case testIndexedGetWithAnyBase]
from typing import Undefined, Any
x = Undefined # type: Any
i = x[1] # type: int
[out]
any x
int i = {int x[{any <= int 1}]}

[case testIndexedGetInDynamicallyTypedFunction]
import typing
def f():
    1[2]
[out]
...
any f():
    {any <= int 1}[{any <= int 2}]
...

[case testIndexedSet]
from typing import Undefined, Any
class A:
    def __setitem__(self, x: 'A', y: int) -> int: pass
x = Undefined # type: Any
a = Undefined # type: A
a[x] = 1
a[a] = x
[out]
...
A a
a[{A x}] = 1
a[a] = {int x}

[case testIndexedSetInDynamicallyTypedFunction]
import typing
def f():
    1[2] = 3
[out]
...
any f():
    {any <= int 1}[{any <= int 2}] = {any <= int 3}
...

[case testIndexedSetWithAnyBase]
from typing import Undefined, Any
x = Undefined # type: Any
x[1] = 2
[out]
any x
x[{any <= int 1}] = {any <= int 2}

[case testGenericOperatorMethod]
from typing import typevar, Undefined, Any
t = typevar('t')
class A:
    def __add__(self, x: t) -> t: pass
x = Undefined # type: Any
a = Undefined # type: A
x = a + 1
[out]
...
A a
x = a + {any <= int 1}

[case testGenericIndexedGet]
from typing import typevar, Generic, Undefined, Any
t = typevar('t')
class A:
    def __getitem__(self, x: t) -> 'B[t]': pass
class B(Generic[t]): pass
x = Undefined # type: Any
a = Undefined # type: A
b = a[x] # type: B[int]
[out]
...
A a
B b = a[{int x}]

[case testInOperator]
from typing import Undefined, Any
class A:
    def __contains__(self, a: 'A') -> int: pass
x = Undefined # type: Any
a = Undefined # type: A
x = x in a
[out]
...
A a
x = {any <= int {A x} in a}

[case testUnaryOperator]
from typing import Undefined, Any
class A:
    def __neg__(self) -> bool: pass
x = Undefined # type: Any
a = Undefined # type: A
x = -a
[builtins fixtures/ops.py]
[out]
...
A a
x = {any <= bool -a}

[case testTransformBinaryOpOperands]
from typing import Any, Undefined
class A:
    def __add__(self, x: 'A') -> int: pass
def f(x: Any) -> A: pass
a = Undefined # type: A
a + f(1)
[out]
...
A a
a + f({any <= int 1})

[case testTransformIndexExpr]
from typing import Any, Undefined
class A:
    def __getitem__(self, x: 'A') -> int: pass
def f(x: Any) -> A: pass
a = Undefined # type: A
a[f(1)]
[out]
...
A a
a[f({any <= int 1})]

[case testTransformUnaryOperand]
from typing import Any
class A:
    def __neg__(self) -> int: pass
def f(x: Any) -> A: pass
-f(1)
[out]
...
-f({any <= int 1})
