-- Test cases for runtime (dynamic) checking transformation.
--
-- Each test case consists of at least two sections.
-- The first section contains [case NAME] followed by the input code, while
-- the second section contains [out] followed by the output from the
-- transformation.

-- Note that the test cases use a pretty-printed output syntax that is not
-- valid mypy code.


-- Empty method transformation, no inheritance
-- -------------------------------------------


[case testEmptyClass]
class A: pass
class B: pass
[out]
class A:
    pass
any A*():
    return A()
class B:
    pass
any B*():
    return B()

[case testSimpleMethod]
class A:
    void __init__(self):
        pass
    
    int f(self):
        pass
[out]
class A:
    void __init__(A self):
        pass
    int f(A self):
        pass
    any f*(any self):
        return {any <= int {A self}.f()}
any A*():
    return A()

[case testMethodWithArguments]
class A:
    void __init__(self):
        pass
    
    void f(self, A a):
        pass
[out]
class A:
    void __init__(A self):
        pass
    void f(A self, A a):
        pass
    any f*(any self, any a):
        {A self}.f({A a})
any A*():
    return A()

[case testMethodWithDynamicTypesInArguments]
class A:
    A f(self, any a, any b):
        pass
[out]
class A:
    A f(A self, any a, any b):
        pass
    any f*(any self, any a, any b):
        return {A self}.f(a, b)
any A*():
    return A()

[case testMethodWithDynamicReturnType]
class A:
    any f(self, A a):
        pass
[out]
class A:
    any f(A self, A a):
        pass
    any f*(any self, any a):
        return {A self}.f({A a})
any A*():
    return A()


-- Empty methods with inheritance
-- ------------------------------


[case testOverridingStaticWithDynamic]
class A:
    int f(self, float a):
        pass
class B(A):
    any f(self, any a):
        pass
[out]
class A:
    int f(A self, float a):
        pass
    any f*(any self, any a):
        return {any <= int {A self}.f({float a})}
any A*():
    return A()
class B(__main__.A):
    any f`B(B self, any a):
        pass
    int f(A self, float a):
        return {int {B self}.f`B({any <= float a})}
    any f*(any self, any a):
        return {B self}.f`B(a)
any B*():
    return B()

[case testOverridingDynamicWithStatic]
class A:
    any f(self, any a):
        pass
class B(A):
    int f(self, A a):
        pass
[out]
class A:
    any f(A self, any a):
        pass
    any f*(any self, any a):
        return {A self}.f(a)
...
class B(__main__.A):
    int f`B(B self, A a):
        pass
    any f(A self, any a):
        return {any <= int {B self}.f`B({A a})}
    any f*(any self, any a):
        return {any <= int {B self}.f`B({A a})}
...

[case testNewMethodInSubclass]
class A:
    B f(self, A a):
        pass
class B(A):
    A g(self, B b):
        pass
[out]
class A:
    B f(A self, A a):
        pass
    any f*(any self, any a):
        return {A self}.f({A a})
...
class B(__main__.A):
    A g(B self, B b):
        pass
    any g*(any self, any b):
        return {B self}.g({B b})
...

[case testOverridingMethodInGrandparent]
class A:
    B f(self, int a):
        pass
class B(A): pass
class C(B):
    any f(self, any a):
        pass
[out]
...
class B(__main__.A):
    pass
...
class C(__main__.B):
    any f`C(C self, any a):
        pass
    B f(A self, int a):
        return {B {C self}.f`C({any <= int a})}
    any f*(any self, any a):
        return {C self}.f`C(a)
...

[case testOverridingMethodTwice]
class A:
    float f(self, int a):
        pass
class B(A):
    float f(self, any a):
        pass
class C(B):
    any f(self, int a):
        pass
[out]
...
class B(__main__.A):
    float f`B(B self, any a):
        pass
    float f(A self, int a):
        return {B self}.f`B({any <= int a})
    any f*(any self, any a):
        return {any <= float {B self}.f`B(a)}
...
class C(__main__.B):
    any f`C(C self, int a):
        pass
    float f`B(B self, any a):
        return {float {C self}.f`C({int a})}
    any f*(any self, any a):
        return {C self}.f`C({int a})
...

[case testOverridingWithSameSig]
class A:
    B f(self, A a):
        pass
class B(A):
    B f(self, A a):
        return None
[out]
...
class B(__main__.A):
    B f(B self, A a):
        return None
any B*():
...

[case testOverridingDynamicWithDynamic]
class A:
    any f(self, any a):
        pass
class B(A):
    any f(self, any a):
        return None
[out]
...
class B(__main__.A):
    any f(B self, any a):
        return None
any B*():
...

[case testOverridingFirstWithDynamicAndThenWithSameSig]
class A:
    void f(self, int a):
        self.f(a)
class B(A):
    void f(self, any a):
        self.f(a)
class C(B):
    void f(self, any a):
        self.f(a)
[out]
...
class B(__main__.A):
    void f`B(B self, any a):
        self.f`B(a)
    void f(A self, int a):
        {B self}.f`B({any <= int a})
    any f*(any self, any a):
        {B self}.f`B(a)
...
class C(__main__.B):
    void f`B(C self, any a):
        self.f`B(a)
any C*():
...


-- Method calls
-- ------------


[case testCallStaticallyTypedMethod]
class A:
    A f(self, B b):
        return b.g()
class B:
    A g(self):
        pass
[out]
class A:
    A f(A self, B b):
        return b.g()
...

[case testCallDynamicallyTypedMethod]
class A:
    any f(self, any b):
        return b.g()
class B:
    A g(self):
        pass
[out]
class A:
    any f(A self, any b):
        return b.g*()
...

[case testStaticCallWithArguments]
class A:
    A f(self, B b):
        return b.g(b, 1)
class B:
    A g(self, B b, any d):
        pass
[out]
class A:
    A f(A self, B b):
        return b.g(b, {any <= int 1})
...

[case testDynamicCallWithArguments]
class A:
    A f(self, any d, int i):
        return d.g(d, i)
[out]
class A:
    A f(A self, any d, int i):
        return {A d.g*(d, {any <= int i})}
...

[case testMethodCallWithInheritance]
class A:
    A f1(self, B b):
        return b.f1(b)
    B f2(self, B b, A a):
        return b.g(a)
class B(A):
    B g(self, A a):
        pass
[out]
class A:
    A f1(A self, B b):
        return b.f1(b)
...
    B f2(A self, B b, A a):
        return b.g(a)
...

[case testMethodCallWithOverride]
class A:
    A f(self, B b):
        return b.f(b)
    A f2(self, A a, B b):
        return a.f(b)
class B(A):
    any f(self, B b):
        pass
[out]
class A:
    A f(A self, B b):
        return {A b.f`B(b)}
...
    A f2(A self, A a, B b):
        return a.f(b)
...

[case testNestedMethodCalls]
class A:
    any f(self, A a):
        return a.g(a.g(1))
    int g(self, any a):
        pass
[out]
class A:
    any f(A self, A a):
        return {any <= int a.g({any <= int a.g({any <= int 1})})}
...

[case testMethodCallViaSelf]
class A:
    any f(self, int a):
        return self.g(a)
    int g(self, any a):
        pass
[out]
class A:
    any f(A self, int a):
        return {any <= int self.g({any <= int a})}
...


-- Statements
-- ----------


[case testReturnStatement1]
class A:
    any f(self, B b):
        return b.g()
class B:
    A g(self):
        pass
[out]
class A:
    any f(A self, B b):
        return b.g()
    any f*(any self, any b):
        return {A self}.f({B b})
...

[case testReturnStatement2]
class A:
    A f(self, B b):
        return b.g()
class B:
    any g(self):
        pass
[out]
class A:
    A f(A self, B b):
        return {A b.g()}
    any f*(any self, any b):
        return {A self}.f({B b})
...

[case testIfStatement]
bool b
any d
if b:
    d = 1
elif d:
    d = 2
else:
    d = 3
[builtins fixtures/ops.py]
[out]
...
if b:
    d = {any <= int 1}
elif d:
    d = {any <= int 2}
else:
    d = {any <= int 3}

[case testWhileStatement]
bool b
any d
while b:
    while d:
        d = 1
[builtins fixtures/ops.py]
[out]
...
while b:
    while d:
        d = {any <= int 1}


-- Cast insertion (or non-insertion) in specific cases
-- ---------------------------------------------------


[case testOmitSubtypeToSupertypeCast]
class A:
    A f(self, B b):
        return b
class B(A): pass
[out]
class A:
    A f(A self, B b):
        return b
...


-- Constructor and object construction
-- -----------------------------------


[case testBasicConstructor]
class A:
    int a
    any d
    
    void __init__(self, int a, any d):
        self.a = a
        self.d = d
[out]
class A
...
  def create(a as Int, d as dynamic)
    self.a = a
    self.d = d
  end
end

[case testCreateInstanceWithExactTypes]
class A:
    void __init__(self, B b):
        pass
    
    A f(self, B b):
        return A(b)
class B: pass
[out]
class A
  def create(b as B)
  end

  def f(b as B) as A
    return A(b)
  end
...

[case testCreateInstanceWithTrivialReturnTypeCoercion]
class A:
    any f(self):
        return A()
[out]
class A
  def f() as dynamic
    return A()
  end
...

[case testCreateInstanceWithArgumentCasts]
class A:
    B f(self, int b, any d):
        return B(b, d)
class B:
    void __init__(self, any d, A a):
        pass
[out]
class A
  def f(b as Int, d as dynamic) as B
    return B({dyn <= std::Int | b}, {A <= dyn | d})
  end
...


-- Self expressions
-- ----------------


[case testSelf]
class A:
    void f(self, any a):
        self.f(self)
[out]
class A:
    void f(A self, any a):
        self.f(self)
...


-- Member variable access
-- ----------------------


[case testMemberVariableAccessors]
class A:
    int a
    any d
    
    void __init__(self, int a, any d):
        self.a = a
        self.d = d
[out]
class A
  var a as Int
  def a* as dynamic
    return {dyn <= std::Int | self.a}
  end
  def a* = __x as dynamic
    self.a = {std::Int <= dyn | __x}
  end
  var d as dynamic
  def d* as dynamic
    return self.d
  end
  def d* = __x as dynamic
    self.d = __x
  end
...

[case testMemberVariableAccessViaStatic]
class A:
    int a
    any d
    int f(self):
        return self.d
    any g(self):
        return self.a
    
    void __init__(self, int a, any d):
        self.a = a
        self.d = d
[out]
class A
...
  def f() as Int
    return {std::Int <= dyn | self.d}
  end
...
  def g() as dynamic
    return {dyn <= std::Int | self.a}
  end
...

[case testMemberVariableAccessViaDynamic]
class A:
    A f(self, any d):
        return d.x
[out]
class A
  def f(d as dynamic) as A
    return {A <= dyn | d.x*}
  end
...

[case testMemberVariableAssignmentViaDynamic]
any d
d.x = 1
[out]
...
d.x* = {dyn <= std::Int | 1}


-- Casts
-- -----


[case testCast]
class A:
    B f(self, A a):
        return (B)a
class B(A): pass
[out]
class A:
    B f(A self, A a):
        return (B)a
...

[case testDynamicCast]
class A:
    float f(self, int a):
        return (any)a
[out]
class A:
    float f(A self, int a):
        return {float (any){any <= int a}}
...

[case testNestedCasts]
(int)(any)1
[out]
(int)(any){any <= int 1}


-- Global expressions
-- ------------------


[case testGlobalExpression]
class A:
    void f(self, any a):
        pass

A().f(1)
[out]
...
A().f({any <= int 1})


-- Void type
-- ---------


[case testVoidReturn]
class A:
    void f(self, any b):
        pass
class B(A):
    void f(self, B b):
        pass
[out]
class A:
    void f(A self, any b):
        pass
    any f*(any self, any b):
        {A self}.f(b)
any A*():
    return A()
class B(__main__.A):
    void f`B(B self, B b):
        pass
    void f(A self, any b):
        {B self}.f`B({B b})
    any f*(any self, any b):
        {B self}.f`B({B b})
any B*():
    return B()


-- Function definition and call
-- ----------------------------


[case testFunctionDefinitionAndCall]
int f(int a):
    return (any)1
any d
d = f((any)1)
[out]
int f(int a):
    return {int (any){any <= int 1}}
any d
d = {any <= int f({int (any){any <= int 1}})}


-- Assignment and initialization
-- -----------------------------


[case testAssignmentToGlobal]
int a
any d
a = a
a = d
d = a
[out]
int a
any d
a = a
a = {int d}
d = {any <= int a}

[case testGlobalInitialization]
int a
any d
any dd = a
int aa = a
[out]
var a as Int
var d as dynamic
var dd = {dyn <= std::Int | a} as dynamic
var aa = a as Int

[case testLocalVariableAssignmentAndInit]
void f():
    int a
    any d = a
    int aa = a
    a = a
    d = a
[out]
def f() as void
  var a as Int
  var d = {dyn <= std::Int | a} as dynamic
  var aa = a as Int
  a = a
  d = {dyn <= std::Int | a}
end

[case testAssignmentToMemberUsingDot]
A a
any d
a.m = d
a.m = a

class A:
    A m
    
    void __init__(self, A m):
        self.m = m
[out]
...
a.m = {A <= dyn | d}
a.m = a
...

[case testDirectAssignmentToMember]
class A:
    int m
    any d
    
    void f(self):
        self.m = self.m
        self.d = self.d
        self.m = self.d
        self.d = self.m
    
    void __init__(self, int m, any d):
        self.m = m
        self.d = d
[out]
...
  def f() as void
    m = m
    d = d
    m = {std::Int <= dyn | d}
    d = {dyn <= std::Int | m}
  end
...

[case testMemberInitialization]
class A:
    int a
    any d = self.a
    int b = self.a
    
    void __init__(self, int a):
        self.a = a
[out]
class A
  var a as Int
...
  var d = {dyn <= std::Int | a} as dynamic
...
  var b = a as Int
...


-- nil
-- ---


[case testInitializationToNil]
object a = None
any d = None
[out]
var a = nil as Object
var d = nil as dynamic

[case testNilFunctionArgument]
void f(A a):
    pass
f(None)
class A: pass
[out]
...
f(nil)
...


-- Displaying debugging information
-- --------------------------------


[case testSimplePrint]
# The arguments to debugging functions are not coerced.
__Print('hello')
[out]
__Print('hello')

[case testComplexPrint]
any f(any a):
    pass
int a
__Print(a, f(a))
[out]
...
var a as Int
__Print(a, f({dyn <= std::Int | a}))


-- Coercions from primitive types
-- ------------------------------


[case testCoercionFromPrimitiveToObject]
object o
int i
float f
A a
o = i
o = f
o = a
i = i
class A: pass
[out]
...
var a as A
o = {std::Object <= std::Int | i}
o = {std::Object <= std::Float | f}
o = a
i = i
...


-- Primitive operations
-- --------------------


[case testIntLiterals]
int a = 1
any d = 1
[out]
var a = 1 as Int
var d = {dyn <= std::Int | 1} as dynamic


[case testIntArithmetic]
int i
any d
i = 1 + 2
i = (1 - 2) * 2
i = 1 % 2
i = 1 // 2
i = -i
d = 1 + d
d = 1 - d
d = 1 * d
d = 1 % d
d = 1 // d
d = -d + d - d * d
d = d + 1
d = d - 1
d = d * 1
d = d % d
d = d // d
[builtins fixtures/ops.py]
[out]
...
i = 1 + 2
-- TODO why the extra space?
i = ( 1 - 2) * 2
i = 1 mod 2
i = 1 div 2
i = -i
d = {dyn <= std::Int | 1 + d}
d = {dyn <= std::Int | 1 - d}
d = {dyn <= std::Int | 1 * d}
d = {dyn <= std::Int | 1 mod d}
d = {dyn <= std::Int | 1 div d}
d = -d + d - d * d
d = d + 1
d = d - 1
d = d * 1
d = d mod d
d = d div d


[case testBinaryOperationOperands]
any d
int i
i = d.g() + d.f()
i = d.g() * d.f()
i = i + d.f()
i = -d.g()
[builtins fixtures/ops.py]
[out]
...
i = {std::Int <= dyn | d.g*() + d.f*()}
i = {std::Int <= dyn | d.g*() * d.f*()}
i = i + d.f*()
i = {std::Int <= dyn | -d.g*()}


[case testBools]
bool b
any d
b = True
b = False
d = True
d = False
b = b and b
d = b or b
b = not b
d = not b
b = b and d
d = b or d
b = d and b
d = d or b
b = d and d
d = d or d
b = not d
[builtins fixtures/ops.py]
[out]
var b as Boolean
var d as dynamic
b = True
b = False
d = {dyn <= std::Boolean | True}
d = {dyn <= std::Boolean | False}
b = b and b
d = {dyn <= std::Boolean | b or b}
b = not b
d = {dyn <= std::Boolean | not b}
b = b and {std::Boolean <= dyn | d}
d = {dyn <= std::Boolean | b or {std::Boolean <= dyn | d}}
b = {std::Boolean <= dyn | d} and b
d = {dyn <= std::Boolean | {std::Boolean <= dyn | d} or b}
b = {std::Boolean <= dyn | d} and {std::Boolean <= dyn | d}
d = {dyn <= std::Boolean | {std::Boolean <= dyn | d} or {std::Boolean <= dyn | d}}
b = not d


[case testIntComparisons]
int i
bool b
any d
b = 1 == 2
d = 1 != 2
b = 1 < 2
b = 1 <= 2
b = 1 > 2
b = 1 >= 2
b = d == d
d = d == d
b = d != 1
b = 1 < d
d = 1 > d
[builtins fixtures/ops.py]
[out]
...
b = 1 == 2
d = {dyn <= std::Boolean | 1 != 2}
b = 1 < 2
b = 1 <= 2
b = 1 > 2
b = 1 >= 2
b = d == d
d = {dyn <= std::Boolean | d == d}
b = d != 1
b = 1 < d
d = {dyn <= std::Boolean | 1 > d}


[case testNilComparison]
bool b
C c
b = b is None
b = c is not None
b = None == b
b = None != c
class C: pass
[builtins fixtures/ops.py]
[out]
...
b = b == nil
b = c != nil
b = nil == b
b = nil != c
...


[case testStrLiterals]
str s = 'foo'
__Print(s)
__Print('bar')
[out]
var s = 'foo' as Str
__Print(s)
__Print('bar')


-- Implicit dynamic types
-- ----------------------


[case testImplicitGlobalVarType]
any a
object b = a
c = b
b = c
[out]
var a
var b = {std::Object <= dyn | a} as Object
var c = b
b = {std::Object <= dyn | c}

[case testImplicitPrivateMemberVarType]
class A:
    any a
    c = None
    
    void f(self):
        A b = self.a
        b = self.c
[out]
class A
...
  def f() as void
    var b = {A <= dyn | a} as A
    b = {A <= dyn | c}
  end
...

[case testImplicitPublicMemberVarType]
class A:
    any a
    c = None
    
    void f(self):
        A b = self.a
        b = self.c
    
    void __init__(self, any a):
        self.a = a
[out]
class A
  var a
  def a* as dynamic
    return self.a
  end
  def a* = __x as dynamic
    self.a = __x
  end
  var c = nil
  def c* as dynamic
    return self.c
  end
  def c* = __x as dynamic
    self.c = __x
  end

  def f() as void
    var b = {A <= dyn | a} as A
    b = {A <= dyn | c}
  end
...

[case testImplicitFunctionSig]
def f(a, b):
    pass
void g():
    int i = f(1, 2)
[out]
def f(a, b)
end
def g() as void
  var i = {std::Int <= dyn | f({dyn <= std::Int | 1}, \
                               {dyn <= std::Int | 2})} as Int
end

[case testImplicitMethodSig]
class A:
    def f(self, a):
        pass
    void g(self):
        int i = self.f(1)
        int j = self.f(1)
[out]
class A
  def f(a)
  end
  def f*(a as dynamic) as dynamic
    return f(a)
  end
  def g() as void
    var i = {std::Int <= dyn | f({dyn <= std::Int | 1})} as Int
    var j = {std::Int <= dyn | self.f({dyn <= std::Int | 1})} as Int
  end
...

[case testImplicitMethodSigInGenericClass]
class A<T>:
    def f(self, a):
        pass
    void g(self):
        int i = self.f(1)
        int j = self.f(1)
[out]
...
class A*
...
  def f(a as dynamic) as dynamic
    return self.__o.f(a)
  end
  def f*(a as dynamic) as dynamic
    return self.__o.f(a)
  end
...
end

[case testImplicitMethodSigAndOverride]
class A:
    def f(self, a):
        pass
    A g(self, A a):
        pass
class B(A):
    def f(self, a):
        pass
    def g(self, a):
        pass
[out]
...
class B is A
  def f(a)
  end
  def g`B(a)
  end
  def g(a as A) as A
    return {A <= dyn | g`B(a)}
  end
  def g*(a as dynamic) as dynamic
    return g`B(a)
  end
end

[case testDynamicallyTypedFunctionBody]
def f(x):
    y = 1
    i + y
    o + o
    x = g(o)
int g(int x):
    pass
int i
object o
[out]
def f(x)
  var y = {dyn <= std::Int | 1}
{dyn <= std::Int |  i} + y
{dyn <= std::Object |  o} + o
  x = {dyn <= std::Int | g({std::Int <= dyn | o})}
end
...

[case testDynamicallyTypedMethodBody]
class A:
    int i
    def f(self, x):
        x = self.g(x)
        x = self.z()
        x = self.i
        x.y()
    int g(self, int x):
        pass
[out]
class A
  private var i as Int
  def f(x)
    x = {dyn <= std::Int | g({std::Int <= dyn | x})}
    x = {dyn <= A | self}.z*()
    x = {dyn <= std::Int | i}
    x.y*()
  end
...


-- additional basic features
--   pretty-printing values
--   void type
