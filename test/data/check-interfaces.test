-- Type checker test cases for interfaces.


-- Subtyping with interfaces
-- -------------------------


[case testInterfaceSubtypingViaImplementation]
from typing import Undefined
from abc import abstractmethod, ABCMeta

i = Undefined # type: I
j = Undefined # type: J
a = Undefined # type: A
b = Undefined # type: B
c = Undefined # type: C

j = c  # E: Incompatible types in assignment
a = i  # E: Incompatible types in assignment
a = j  # E: Incompatible types in assignment
b = i  # E: Incompatible types in assignment

i = a
i = b
i = c
j = a
j = b
a = b

class I(metaclass=ABCMeta): pass
class J(metaclass=ABCMeta): pass
class A(I, J): pass
class B(A): pass
class C(I): pass

[case testInterfaceSubtypingViaExtension]
from typing import Undefined
from abc import abstractmethod, ABCMeta

i = Undefined # type: I
j = Undefined # type: J
a = Undefined # type: A
o = Undefined # type: object

j = i # E: Incompatible types in assignment
a = i # E: Incompatible types in assignment
a = j # E: Incompatible types in assignment
i = o # E: Incompatible types in assignment
j = o # E: Incompatible types in assignment

i = a
j = a
i = j
o = i
o = j

class I(metaclass=ABCMeta): pass
class J(I): pass
class A(J): pass

[case testImplementingInSubclass]
from typing import Undefined
from abc import abstractmethod, ABCMeta

i = Undefined # type: I
a = Undefined # type: A
b = Undefined # type: B

i = a # E: Incompatible types in assignment
b = a # E: Incompatible types in assignment

a = b
i = b

class I(metaclass=ABCMeta): pass
class A: pass
class B(A, I): pass


-- Interfaces objects
-- ------------------


[case testInterfaceAsTypeObject]
from typing import Undefined
from abc import abstractmethod, ABCMeta

o = Undefined # type: object
t = Undefined # type: type

o = I
t = I

class I(metaclass=ABCMeta): pass

[case testInterfacesInCasts-skip]
from typing import Undefined, cast
from abc import abstractmethod, ABCMeta

i, a, b = Undefined, Undefined, Undefined # type: (I, A, B)
o = Undefined # type: object

a = cast('I', o) # E: Incompatible types in assignment
b = cast('B', i) # Ok; a subclass of B might implement I
i = cast('I', b) # Ok; a subclass of B might implement I

i = cast('I', o)
i = cast('I', a)

class I(metaclass=ABCMeta): pass
class A(I): pass
class B: pass

[case testConstructingInterface-skip]
from abc import abstractmethod, ABCMeta
import typing
I()
J()

class I(metaclass=ABCMeta): pass
class J(metaclass=ABCMeta):
    @abstractmethod
    def __init__(self): pass
[out]
main, line 3: "type" not callable
main, line 4: "type" not callable
main: In interface "J":
main, line 9: An interface must not define a constructor


-- Implementing interface methods
-- ------------------------------


[case testImplementingInterfaceMethod-skip]
from abc import abstractmethod, ABCMeta
import typing
class A('I'):
    def f(self, x: 'B') -> 'A': # E: Argument 1 of "f" incompatible with supertype "I"
        pass
    def g(self, x: 'A') -> 'A':
        pass

class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self, x: A) -> A: pass
    @abstractmethod
    def g(self, x: A) -> A: pass

class B: pass
[out]
main: In class "A":

[case testImplementingInterfaceMethodWithMultipleInterfaces-skip]
from abc import abstractmethod, ABCMeta
import typing
class A('I', 'J'):
    def f(self, x: 'B') -> 'A': # Fail
        pass
    def g(self, x: 'A') -> 'B': # Fail
        pass
    def h(self) -> 'B': # Not related to any interface
        pass
class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self, x: A) -> A: pass
class J(metaclass=ABCMeta):
    @abstractmethod
    def g(self, x: A) -> A: pass
class B: pass
[out]
main: In class "A":
main, line 4: Argument 1 of "f" incompatible with supertype "I"
main, line 6: Return type of "g" incompatible with supertype "J"

[case testImplementingInterfaceMethodWithExtension-skip]
from abc import abstractmethod, ABCMeta
import typing
class A('I'):
    def f(self, x: 'B') -> 'A': # E: Argument 1 of "f" incompatible with supertype "J"
        pass
class I('J'): pass
class J(metaclass=ABCMeta):
    @abstractmethod
    def f(self, x: A) -> A: pass
class B: pass
[out]
main: In class "A":

[case testInvalidSubinterfaceMethod-skip]
from abc import abstractmethod, ABCMeta
import typing
class I('J'):
    @abstractmethod
    def f(self, x: 'I') -> None: pass
class J(metaclass=ABCMeta):
    @abstractmethod
    def f(self, x: 'J') -> None: pass
[out]
main: In interface "I":
main, line 5: Argument 1 of "f" incompatible with supertype "J"

[case testInterfaceCoAndContraVariance-skip]
from abc import abstractmethod, ABCMeta
import typing
class A('I'):
    def h(self, a: 'A') -> 'I': # Fail
        pass
    def f(self, a: 'I') -> 'I': # Fail
        pass
    def g(self, a: 'A') -> 'A':
        pass
class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self, a: A) -> 'I': pass
    @abstractmethod
    def g(self, a: A) -> 'I': pass
    @abstractmethod
    def h(self, a: 'I') -> A: pass
[out]
main: In class "A":
main, line 4: Argument 1 of "h" incompatible with supertype "I"
main, line 4: Return type of "h" incompatible with supertype "I"
main, line 6: Argument 1 of "f" incompatible with supertype "I"


-- Accessing interface members
-- ---------------------------


[case testAccessingInterfaceMethod-skip]
from typing import Undefined
from abc import abstractmethod, ABCMeta

i, a, b = Undefined, Undefined, Undefined # type: (I, A, B)

a = i.f(a) # E: Incompatible types in assignment
b = i.f(b) # E: Argument 1 to "f" of "I" has incompatible type "B"
i.g()      # E: "I" has no attribute "g"

b = i.f(a)

class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self, a: 'A') -> 'B': pass

class A: pass
class B: pass

[case testAccessingInheritedInterfaceMethod-skip]
from typing import Undefined
from abc import abstractmethod, ABCMeta

i, a, b = Undefined, Undefined, Undefined # type: (I, A, B)

a = i.f(a) # E: Incompatible types in assignment
b = i.f(a)

class I('J'): pass
class J(metaclass=ABCMeta):
    @abstractmethod
    def f(self, a: 'A') -> 'B': pass

class A: pass
class B: pass


-- Dynamic types
-- -------------


[case testInterfacesWithAllDynamicTypes-skip]
from abc import abstractmethod, ABCMeta
import typing
class A('I'):
    def f(self, x):
        pass

class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self, x): pass

[case testTypedInterfaceWithUntypedImplementation-skip]
from abc import abstractmethod, ABCMeta
import typing
class A('I'):
    def f(self, x):
        pass
class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self, x: A) -> None: pass


-- Missing implementations
-- -----------------------


[case testMethodWithoutImplementation-skip]
from abc import abstractmethod, ABCMeta
import typing
class A('I'): pass
class I(metaclass=ABCMeta):
  @abstractmethod
  def f(self) -> None: pass
[out]
main: In class "A":
main, line 3: "A" does not implement "f" defined in "I"

[case testMethodWithoutImplementationWithInterfaceInheritance-skip]
from abc import abstractmethod, ABCMeta
import typing
class A('J'): pass
class J('I'): pass
class I(metaclass=ABCMeta):
  @abstractmethod
  def f(self) -> None: pass
[out]
main: In class "A":
main, line 3: "A" does not implement "f" defined in "I"


-- Special cases
-- -------------


[case testMultipleBaseInterfaces-skip]
from abc import abstractmethod, ABCMeta
import typing
class A(metaclass=ABCMeta):
  @abstractmethod
  def f(self) -> None: pass
class B(metaclass=ABCMeta):
  @abstractmethod
  def g(self) -> None: pass
class C(A, B):
  @abstractmethod
  def h(self) -> None: pass

[case testMemberAccessWithMultipleBaseInterfaces-skip]
from typing import Undefined
from abc import abstractmethod, ABCMeta

class A(metaclass=ABCMeta): pass
class B(metaclass=ABCMeta):
    @abstractmethod
    def f(self) -> None: pass
class C(A, B): pass
x = Undefined # type: C
x.f()
x.f(x) # E: Too many arguments for "f" of "B"
