-- Test cases for runtime (dynamic) checking transformation and generic
-- inheritance.
--
-- See dyncheck-trans-basic.test for an overview of the file format.


-- Non-generic class inherits a generic class
-- ------------------------------------------


[case testInheritingGenericClass]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]):
    def f(self, t: T) -> None:
        pass
class B('A[C]'):
    def g(self, c: 'C') -> None:
        self.f(c)
class C: pass
[out]
...
class B(A):
    void g(B self, C c):
        self.f(c)
    any g*(any self, any c):
        {B self}.g({C c})
...

[case testInheritingGenericClassAndExternalAccess]
from typing import Undefined, typevar, Generic
T = typevar('T')
b = Undefined # type: B
c = Undefined # type: C
b.f(c)
b.g(c)
class A(Generic[T]):
    def f(self, t: T) -> None:
        pass
class B('A[C]'):
    def g(self, c: 'C') -> None:
        self.f(c)
class C: pass
[out]
B b
C c
b.f(c)
b.g(c)
...

[case testInheritingGenericClassAndOverriding]
from typing import Undefined, typevar, Generic
T = typevar('T')
a = Undefined # type: A[C]
b = Undefined # type: B
c = Undefined # type: C
a.f(c)
b.f(c)
class A(Generic[T]):
    def f(self, t: T) -> None:
        pass
class B('A[C]'):
    def f(self, c: 'C') -> None:
        pass
class C: pass
[out]
...
a.f(c)
b.f`B(c)
...
class B(A):
    void f`B(B self, C c):
        pass
    void f(A self, any t):
        {B self}.f`B(t)
    any f*(any self, any c):
        {B self}.f`B({C c})
...

[case testInheritGenericClassAndConstructInstance]
from typing import typevar, Generic
T = typevar('T')
A[float]()
B()
class A(Generic[T]): pass
class B(A[int]): pass
[out]
A(<float>)
B()
...

[case testInheritingGenericClassAndOverriding2]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]):
    def f(self, a: 'C[T]', b: 'D') -> None:
        pass
class B('A[E]'):
    def f(self, a: 'C[E]', b: 'D') -> None:
        pass
class C(Generic[T]): pass
class D: pass
class E: pass
[out]
...
class B(A):
    void f`B(B self, C a, D b):
        pass
    void f(A self, C a, D b):
        {B self}.f`B(a, b)
    any f*(any self, any a, any b):
        {B self}.f`B({C<E> a}, {D b})
...


-- Generic class inherits a generic class; identical type variables
-- ----------------------------------------------------------------


[case testGenericInheritanceWithIdenticalTypeVars]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
# Single type variable
class A(Generic[T]):
    def f(self, a: T, b: 'A[T]') -> None:
        pass
class B(A[S], Generic[S]):
    def f(self, a: S, b: A[S]) -> None:
        pass
[out]
...
class B(A):
    void f`B(B self, any* a, A b):
        pass
    void f(A self, any a, A b):
        {B<self.__tv> self}.f`B(a, b)
    any f*(any self, any a, any b):
        {B<self.__tv> self}.f`B({self.__tv a}, {A<self.__tv> b})
...
class B**(A**):
...
    void f`B(B self, any a, A b):
        self.__o.f`B({self.__o.__tv {self.__btv a}}, \
                     {A<self.__o.__tv> {A<self.__btv> b}})
    any f*(any self, any a, any b):
        self.__o.f`B({self.__o.__tv {self.__btv a}}, \
                     {A<self.__o.__tv> {A<self.__btv> b}})
...

[case testGenericInheritanceWithIdenticalTypeVars2]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
# Multiple type variables
class A(Generic[T, S]):
    def f(self, a: T, b: 'A[S, T]') -> None:
        pass
class B(A[T, S], Generic[T, S]):
    def f(self, a: T, b: A[S, T]) -> None:
        pass
[out]
...
class B(A):
...
    void f`B(B self, any* a, A b):
        pass
    void f(A self, any a, A b):
        {B<self.__tv, self.__tv2> self}.f`B(a, b)
    any f*(any self, any a, any b):
        {B<self.__tv, self.__tv2> self}.f`B({self.__tv a}, \
                                            {A<self.__tv2, self.__tv> b})
...

[case testGenericInheritanceWithDifferentSig]
from typing import typevar, Generic, Any
T = typevar('T')
S = typevar('S')
# Override with dynamic
class A(Generic[T]):
    def f(self, a: T, b: 'A[T]', i: int) -> T:
        pass
class B(A[S], Generic[S]):
    def f(self, a: Any, b: Any, i: Any) -> Any:
        return None
[out]
...
class B(A):
    any f`B(B self, any a, any b, any i):
        return None
    any f(A self, any a, A b, int i):
        return {self.__tv {B<self.__tv> self}.f`B(a, b, {any <= int i})}
    any f*(any self, any a, any b, any i):
        return {B<self.__tv> self}.f`B(a, b, i)
...


-- Generic class inherits a generic class; different type variables
-- ----------------------------------------------------------------


[case testGenericClassInheritsGenericsClassAndOverrides]
from typing import typevar, Generic
S = typevar('S')
T = typevar('T')
class A(Generic[S, T]):
    def f(self, s: S, t: T) -> None:
        pass
class B('A[C, S]', Generic[S]):
    def f(self, s: 'C', t: S) -> None:
        pass
class C: pass
[out]
...
class B(A):
    void f`B(B self, C s, any* t):
        pass
    void f(A self, any s, any t):
        {B<self.__tv2> self}.f`B(s, t)
    any f*(any self, any s, any t):
        {B<self.__tv2> self}.f`B({C s}, {self.__tv2 t})
...

[case testNonGenericClassInheritsGenericClass]
from typing import typevar, Generic, Any
T = typevar('T')
class A(Generic[T]):
    def f(self, t: T) -> None:
        pass
class B(A[int]):
    def g(self, d: Any) -> None:
        self.f(d)
[out]
...
class B(A):
    void g(B self, any d):
        self.f({int d})
    any g*(any self, any d):
        {B self}.g(d)
...

[case testGenericInheritanceAndCoercionsWithArgShuffling]
from typing import typevar, Generic, Any
T = typevar('T')
S = typevar('S')
X = typevar('X')
Y = typevar('Y')
class A(Generic[T, S]):
    def f(self, t: T, s: S) -> None:
        pass
class B(A[Y, X], Generic[X, Y]):
    def g(self, x: X, y: Y) -> None:
        pass
    def h(self, d: Any) -> None:
        self.f(d, d)
        self.g(d, d)
[out]
...
class B(A):
    void g(B self, any* x, any* y):
        pass
    any g*(any self, any x, any y):
        {B<self.__tv2, self.__tv> self}.g({self.__tv2 x}, {self.__tv y})
    void h(B self, any d):
        self.f({self.__tv d}, {self.__tv2 d})
        self.g({self.__tv2 d}, {self.__tv d})
...
class B**(A**):
...
    void g(B self, any x, any y):
        self.__o.g({self.__o.__tv2 {self.__btv2 x}}, \
                   {self.__o.__tv {self.__btv y}})
    any g*(any self, any x, any y):
        self.__o.g({self.__o.__tv2 {self.__btv2 x}}, \
                   {self.__o.__tv {self.__btv y}})
...

[case testGenericInheritanceAndCoercionsWithNestedArg]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
class A(Generic[T]):
    def f(self, t: T) -> None:
        pass
class B(A[A[S]], Generic[S]):
    def f(self, s: A[S]) -> None:
        pass
[out]
...
class B(A):
    void f`B(B self, A s):
        pass
    void f(A self, any t):
        {B<self.__tv.args[0]> self}.f`B(t)
    any f*(any self, any s):
        {B<self.__tv.args[0]> self}.f`B({A<self.__tv.args[0]> s})
...
class B**(A**):
...
    void f`B(B self, A s):
        self.__o.f`B({A<self.__o.__tv.args[0]> {A<self.__btv.args[0]> s}})
    any f*(any self, any s):
        self.__o.f`B({A<self.__o.__tv.args[0]> {A<self.__btv.args[0]> s}})

[case testGenericInheritanceWithNestedArgs2]
from typing import typevar, Generic, Any
T = typevar('T')
S = typevar('S')
# More complex path to subtype type variable
class A(Generic[T]): pass
class B('A[C[X, A[T]]]', Generic[T]):
    def f(self, a: T, d: Any) -> None:
        a = d
class C(Generic[S, T]): pass
class X: pass
[out]
...
class B(A):
...
    void f(B self, any* a, any d):
        a = {self.__tv.args[1].args[0] d}
...

[case testGenericInheritanceMultipleLevels]
from typing import typevar, Generic, Any
T = typevar('T')
# Two levels of inheritance
class A(Generic[T]):
    def f(self, t: T) -> None:
        pass
class B(A[int]): pass
class C(B, Generic[T]):
    def g(self, t: T, d: Any) -> None:
        self.f(d)
        t = d
[out]
...
class C(B):
...
    void g(C self, any* t, any d):
        self.f({int d})
        t = {self.__tv2 d}
...


-- Constructors with generic inheritance
-- -------------------------------------


-- 1. Wrapper that calls superclass __init__


[case testInheritingGenericClassWithDefaultConstructor]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]): pass
class B(A[int]): pass
[out]
...
class B(A):
    void __init__(B self):
        self.__tv! = <int>
        super().__init__(<int>)
...

[case testInheritingGenericClassWithDefaultConstructor2]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
# Two type arguments
class A(Generic[T, S]): pass
class B(A[int, object]): pass
[out]
...
class B(A):
    void __init__(B self):
        self.__tv! = <int>
        self.__tv2! = <object>
        super().__init__(<int>, <object>)
...

[case testInheritingGenericClassWithNonDefaultConstructor]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]):
    def __init__(self, o: object) -> None:
        pass
class B(A[int]): pass
[out]
...
class B(A):
    void __init__(B self, object o):
        self.__tv! = <int>
        super().__init__(<int>, o)
...

[case testInheritingGenericClassWithNonDefaultConstructor2]
from typing import typevar, Generic
T = typevar('T')
# Two arguments, one with tvar type
class A(Generic[T]):
    def __init__(self, t: T, o: object) -> None:
        pass
class B(A[int]): pass
[out]
...
class B(A):
    void __init__(B self, int t, object o):
        self.__tv! = <int>
        super().__init__(<int>, t, o)
...

[case testInheritingGenericClassFromNonGenericWithDefaultConstructor]
from typing import typevar, Generic
T = typevar('T')
class A: pass
class B(A, Generic[T]): pass
[out]
...
class B(A):
    any __tv
    void __init__(B self, any __tv):
        self.__tv! = <__tv>
        super().__init__()
...

[case testInheritingGenericClassFromNonGenericWithDefaultConstructor2]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
# Superclass defines a non-trivial constructor; two tvars
class A:
    def __init__(self, n: int) -> None:
        pass
class B(A, Generic[T, S]): pass
[out]
...
class B(A):
    any __tv
    any __tv2
    void __init__(B self, any __tv, any __tv2, int n):
        self.__tv! = <__tv>
        self.__tv2! = <__tv2>
        super().__init__(n)
...

[case testInheritingGenericClassFromGenericWithDefaultConstructor]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
U = typevar('U')
class A(Generic[T, S]): pass
class B('A[int, C[U]]', Generic[U]): pass
class C(Generic[T]): pass
[out]
...
class B(A):
    void __init__(B self, any __tv):
        self.__tv! = <int>
        self.__tv2! = <C<__tv>>
        super().__init__(<int>, <C<self.__tv2.args[0]>>)
...

[case testInitWrapperWithDeepHierarchy]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]): pass
class B(A[int]): pass
class C(B, Generic[T]): pass
[out]
...
class C(B):
    any __tv2
    void __init__(C self, any __tv):
        self.__tv! = <int>
        self.__tv2! = <__tv>
        super().__init__()
...

[case testInitWrapperWithDeepHierarchy2]
from typing import typevar, Generic
T = typevar('T')
class A: pass
class B(A): pass
class C(B, Generic[T]): pass
[out]
...
class C(B):
    any __tv
    void __init__(C self, any __tv):
        self.__tv! = <__tv>
        super().__init__()
...


-- 2. Define new constructor in subclass


[case testInitWithGenericInheritance]
from typing import typevar, Generic
T = typevar('T')
U = typevar('U')
S = typevar('S')
class A(Generic[T, U]): pass
class B(A[int, S], Generic[S]):
    def __init__(self, n: int) -> None:
        pass
[out]
...
class B(A):
    void __init__(B self, any __tv, int n):
        self.__tv! = <int>
        self.__tv2! = <__tv>
        pass
...


-- Constructor in a wrapper class; generic inheritance
-- ---------------------------------------------------


[case testInitInWrapperClassWithGenericInheritance]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
U = typevar('U')
# Generic class inherits another generic class
class A(Generic[T, S]): pass
class B('A[int, C[U]]', Generic[U]): pass
class C(Generic[T]): pass
[out]
...
class B**(A**):
    void __init__(any self, any __o, any __tv, any __tv2, \
                  any __btv, any __btv2):
        self.__tv! = <__tv>
        self.__tv2! = <__tv2>
        self.__btv! = <__btv>
        self.__btv2! = <__btv2>
        self.__o! = __o
...

[case testInitInWrapperClassWithInheritance2]
from typing import typevar, Generic
T = typevar('T')
# Original create has arguments; this does not affect the wrapper
class A(Generic[T]):
    def __init__(self, n: int) -> None:
        pass
class B(A[T], Generic[T]): pass
[out]
...
class B**(A**):
    void __init__(any self, any __o, any __tv, any __btv):
...

[case testInitInWrapperClassWithInheritance3]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
# Multi-level inheritance hierarchy; note that there is no wrapper class
# for B.
class A(Generic[T]): pass
class B(A[int]): pass
class C(B, Generic[T, S]): pass
[out]
...
class C**(A**):
    any __tv2
    any __tv3
    any __btv2
    any __btv3
    void __init__(any self, any __o, any __tv, any __tv2, any __tv3, \
                  any __btv, any __btv2, any __btv3):
        self.__tv! = <__tv>
        self.__tv2! = <__tv2>
        self.__tv3! = <__tv3>
        self.__btv! = <__btv>
        self.__btv2! = <__btv2>
        self.__btv3! = <__btv3>
        self.__o! = __o


-- Type variable definitions in subclasses; generic inheritance
-- ------------------------------------------------------------


[case testTvarDefinitionsWithGenericInheritance]
from typing import typevar, Generic
T = typevar('T')
# Generic class inherits generic class; no new type variables
class A(Generic[T]): pass
class B(A[T], Generic[T]): pass
[out]
...
class B(A):
    void __init__(B self, any __tv):
...
class B**(A**):
    void __init__(any self, any __o, any __tv, any __btv):
...

[case testTvarDefinitionsWithGenericInheritance]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
# Generic class inherits generic class; introduce new type variable
class A(Generic[T]): pass
class B(A[T], Generic[S, T]): pass
[out]
...
class B(A):
    any __tv2
    void __init__(B self, any __tv, any __tv2):
...
class B**(A**):
    any __tv2
    any __btv2
    void __init__(any self, any __o, any __tv, any __tv2, \
                  any __btv, any __btv2):
...


-- Calling superclass create explicitly
-- ------------------------------------


[case testGenericInheritanceAndCallToSuperclassInit]
from typing import typevar, Generic
T = typevar('T')
# Non-generic class inherits a generic class
class A(Generic[T]):
    def __init__(self, n: 'C') -> None:
        pass

class C: pass

class B(A[int]):
    def __init__(self) -> None:
        super().__init__(C())
[out]
...
class B(A):
    void __init__(B self):
        self.__tv! = <int>
        super().__init__(<int>, C())
...

[case testGenericInheritanceAndCallToSuperclassInit2-skip]
from typing import typevar, Generic
T = typevar('T')
# Non-generic class inherits a generic class
class A(Generic[T]): pass

class B(A[int]):
    def __init__(self) -> None:
        super().__init__()
[out]
...
class B(A):
    void __init__(B self):
        self.__tv! = <int>
        super().__init__(<int>)
...

[case testGenericInheritanceAndCallToSuperclassInit]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
# Generic class inherits a generic class
class A(Generic[T, S]):
    def __init__(self, t: T) -> None:
        pass

class B(A[S, T], Generic[T, S]):
    def __init__(self, t: S) -> None:
        super().__init__(t)
[out]
...
class B(A):
    void __init__(B self, any __tv, any __tv2, any* t):
        self.__tv! = <__tv2>
        self.__tv2! = <__tv>
        super().__init__(<self.__tv>, <self.__tv2>, t)
...


-- Mixed generic inheritance
-- -------------------------


[case testMixedGenericInheritance-skip]
from typing import typevar, Generic, Any
T = typevar('T')
# Non-generic class extends generic
class A(Generic[T]):
    def f(self, t: T) -> T:
        pass
class B(A[int]):
    def f(self, t: Any) -> Any:
        pass
[out]
...
class B(A):
    any f`B(B self, any t):
        pass
    any f(A self, any t):
-- TODO not sure about the coercions...
        return {any <= int {int {B self}.f`B({any <= int t})}}
    any f*(any self, any t):
        return {B self}.f`B(t)
...

[case testMixedGenericInheritance2]
from typing import typevar, Generic, Any
T = typevar('T')
S = typevar('S')
# Generic class extends generic
class A(Generic[T]):
    def f(self, t: T) -> T:
        pass
class B(A[S], Generic[T, S]):
    def f(self, t: Any) -> Any:
        pass
[out]
...
class B(A):
    any __tv2
    any f`B(B self, any t):
        pass
    any f(A self, any t):
        return {self.__tv {B<self.__tv2, self.__tv> self}.f`B(t)}
    any f*(any self, any t):
        return {B<self.__tv2, self.__tv> self}.f`B(t)
...
class B**(A**):
...
    any f`B(B self, any t):
        return self.__o.f`B(t)
    any f*(any self, any t):
        return self.__o.f`B(t)


-- Generic inheritance with multiple ways of accessing subclass tvars
-- ------------------------------------------------------------------


-- Example: class C<t>(D<t, t>): ...


[case testAmbiguousTvarMappingAndGenericInheritance]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
class D(Generic[T, S]):
    def f(self) -> S:
        pass
class C(D[T, T], Generic[T]):
    def f(self) -> T:
        pass
[out]
...
class C(D):
...
    void __init__(C self, any __tv):
        self.__tv! = <__tv>
        self.__tv2! = <__tv>
        super().__init__(<self.__tv>, <self.__tv>)
...
class C**(D**):
    void __init__(any self, any __o, any __tv, any __tv2, \
                  any __btv, any __btv2):
        self.__tv! = <__tv>
        self.__tv2! = <__tv2>
        self.__btv! = <__btv>
        self.__btv2! = <__btv2>
        self.__o! = __o
    any f`C(C self):
        return {self.__tv {self.__btv self.__o.f`C()}}
    any f*(any self):
        return {self.__btv self.__o.f`C()}


-- Generic inheritance + member variables
-- --------------------------------------


[case testMemberVarsAndGenericClass]
from typing import typevar, Generic, Undefined, Any
T = typevar('T')
class A(Generic[T]):
    x = Undefined # type: T
    def f(self, a: Any) -> None:
        self.x = a
        a = self.x
[out]
class A:
    any __tv
    any* x
    any* $x(A self):
        return self.x!
    void set$x(A self, any* x):
        self.x! = x
    any $x*(A self):
        return self.x!
    void set$x*(A self, any x):
        self.x! = {self.__tv x}
    void f(A self, any a):
        self.x = {self.__tv a}
        a = self.x
...
class A**:
    any __o
    any __tv
    any __btv
    void __init__(any self, any __o, any __tv, any __btv):
        self.__tv! = <__tv>
        self.__btv! = <__btv>
        self.__o! = __o
    any $x(A self):
        return {self.__tv {self.__btv self.__o.$x()}}
    any $x*(any self):
        return {self.__btv self.__o.$x()}
    void set$x(A self, any x):
        self.__o.set$x({self.__o.__tv {self.__btv x}})
    any set$x*(any self, any x):
        self.__o.set$x({self.__o.__tv {self.__btv x}})
    void f(A self, any a):
        self.__o.f(a)
    any f*(any self, any a):
        self.__o.f(a)
...

[case testMemberVarsAndGenericInheritance]
from typing import typevar, Generic, Undefined, Any
T = typevar('T')
class A(Generic[T]):
    x = Undefined # type: T
    def f(self, a: Any) -> None:
        self.x = a
        a = self.x
class B('A[C[T]]', Generic[T]):
    y = Undefined # type: T
    def g(self, a: Any) -> None:
        self.y = a
        a = self.y
class C(Generic[T]): pass
[out]
...
class B(A):
    any* y
    any* $y(B self):
        return self.y!
    void set$y(B self, any* y):
        self.y! = y
    any $y*(B self):
        return self.y!
    void set$y*(B self, any y):
        self.y! = {self.__tv.args[0] y}
    void g(B self, any a):
        self.y = {self.__tv.args[0] a}
        a = self.y
...
