-- Test cases for runtime (dynamic) checking transformation and generic
-- inheritance.
--
-- See dyncheck-trans-basic.test for an overview of the file format.


-- Non-generic class inherits a generic class
-- ------------------------------------------


[case testInheritingGenericClass]
class A<T>:
    void f(self, T t):
        pass
class B(A<C>):
    void g(self, C c):
        self.f(c)
class C: pass
[out]
...
class B(A):
    void g(B self, C c):
        self.f(c)
    any g*(any self, any c):
        {B self}.g({C c})
...

[case testInheritingGenericClassAndExternalAccess]
B b
C c
b.f(c)
b.g(c)
class A<T>:
    void f(self, T t):
        pass
class B(A<C>):
    void g(self, C c):
        self.f(c)
class C: pass
[out]
B b
C c
b.f(c)
b.g(c)
...

[case testInheritingGenericClassAndOverriding]
A<C> a
B b
C c
a.f(c)
b.f(c)
class A<T>:
    void f(self, T t):
        pass
class B(A<C>):
    void f(self, C c):
        pass
class C: pass
[out]
...
a.f(c)
b.f`B(c)
...
class B(A):
    void f`B(B self, C c):
        pass
    void f(A self, any t):
        {B self}.f`B(t)
    any f*(any self, any c):
        {B self}.f`B({C c})
...

[case testInheritGenericClassAndConstructInstance]
A<float>()
B()
class A<T>: pass
class B(A<int>): pass
[out]
A(<float>)
B()
...

[case testInheritingGenericClassAndOverriding2]
class A<T>:
    void f(self, C<T> a, D b):
        pass
class B(A<E>):
    void f(self, C<E> a, D b):
        pass
class C<T>: pass
class D: pass
class E: pass
[out]
...
class B(A):
    void f`B(B self, C a, D b):
        pass
    void f(A self, C a, D b):
        {B self}.f`B(a, b)
    any f*(any self, any a, any b):
        {B self}.f`B({C<E> a}, {D b})
...


-- Generic class inherits a generic class; identical type variables
-- ----------------------------------------------------------------


[case testGenericInheritanceWithIdenticalTypeVars]
# Single type variable
class A<T>:
    void f(self, T a, A<T> b):
        pass
class B<S>(A<S>):
    void f(self, S a, A<S> b):
        pass
[out]
...
class B(A):
    void f`B(B self, any* a, A b):
        pass
    void f(A self, any a, A b):
        {B<self.__tv> self}.f`B(a, b)
    any f*(any self, any a, any b):
        {B<self.__tv> self}.f`B({self.__tv a}, {A<self.__tv> b})
...
class B**(A**):
...
    void f`B(B self, any a, A b):
        self.__o.f`B({self.__o.__tv {self.__btv a}}, \
                     {A<self.__o.__tv> {A<self.__btv> b}})
    any f*(any self, any a, any b):
        self.__o.f`B({self.__o.__tv {self.__btv a}}, \
                     {A<self.__o.__tv> {A<self.__btv> b}})
...

[case testGenericInheritanceWithIdenticalTypeVars2]
# Multiple type variables
class A<T, S>:
    void f(self, T a, A<S, T> b):
        pass
class B<T, S>(A<T, S>):
    void f(self, T a, A<S, T> b):
        pass
[out]
...
class B(A):
...
    void f`B(B self, any* a, A b):
        pass
    void f(A self, any a, A b):
        {B<self.__tv, self.__tv2> self}.f`B(a, b)
    any f*(any self, any a, any b):
        {B<self.__tv, self.__tv2> self}.f`B({self.__tv a}, \
                                            {A<self.__tv2, self.__tv> b})
...

[case testGenericInheritanceWithDifferentSig]
# Override with dynamic
class A<T>:
    T f(self, T a, A<T> b, int i):
        pass
class B<S>(A<S>):
    any f(self, any a, any b, any i):
        return None
[out]
...
class B(A):
    any f`B(B self, any a, any b, any i):
        return None
    any f(A self, any a, A b, int i):
        return {self.__tv {B<self.__tv> self}.f`B(a, b, {any <= int i})}
    any f*(any self, any a, any b, any i):
        return {B<self.__tv> self}.f`B(a, b, i)
...


-- Generic class inherits a generic class; different type variables
-- ----------------------------------------------------------------


[case testGenericClassInheritsGenericsClassAndOverrides]
class A<S, T>:
    void f(self, S s, T t):
        pass
class B<S>(A<C, S>):
    void f(self, C s, S t):
        pass
class C: pass
[out]
...
class B(A):
    void f`B(B self, C s, any* t):
        pass
    void f(A self, any s, any t):
        {B<self.__tv2> self}.f`B(s, t)
    any f*(any self, any s, any t):
        {B<self.__tv2> self}.f`B({C s}, {self.__tv2 t})
...

[case testNonGenericClassInheritsGenericClass]
class A<T>:
    void f(self, T t):
        pass
class B(A<int>):
    void g(self, any d):
        self.f(d)
[out]
...
class B(A):
    void g(B self, any d):
        self.f({int d})
    any g*(any self, any d):
        {B self}.g(d)
...

[case testGenericInheritanceAndCoercionsWithArgShuffling]
class A<T, S>:
    void f(self, T t, S s):
        pass
class B<X, Y>(A<Y, X>):
    void g(self, X x, Y y):
        pass
    void h(self, any d):
        self.f(d, d)
        self.g(d, d)
[out]
...
class B(A):
    void g(B self, any* x, any* y):
        pass
    any g*(any self, any x, any y):
        {B<self.__tv2, self.__tv> self}.g({self.__tv2 x}, {self.__tv y})
    void h(B self, any d):
        self.f({self.__tv d}, {self.__tv2 d})
        self.g({self.__tv2 d}, {self.__tv d})
...
class B**(A**):
...
    void g(B self, any x, any y):
        self.__o.g({self.__o.__tv2 {self.__btv2 x}}, \
                   {self.__o.__tv {self.__btv y}})
    any g*(any self, any x, any y):
        self.__o.g({self.__o.__tv2 {self.__btv2 x}}, \
                   {self.__o.__tv {self.__btv y}})
...

[case testGenericInheritanceAndCoercionsWithNestedArg]
class A<T>:
    void f(self, T t):
        pass
class B<S>(A<A<S>>):
    void f(self, A<S> s):
        pass
[out]
...
class B(A):
    void f`B(B self, A s):
        pass
    void f(A self, any t):
        {B<self.__tv.args[0]> self}.f`B(t)
    any f*(any self, any s):
        {B<self.__tv.args[0]> self}.f`B({A<self.__tv.args[0]> s})
...
class B**(A**):
...
    void f`B(B self, A s):
        self.__o.f`B({A<self.__o.__tv.args[0]> {A<self.__btv.args[0]> s}})
    any f*(any self, any s):
        self.__o.f`B({A<self.__o.__tv.args[0]> {A<self.__btv.args[0]> s}})

[case testGenericInheritanceWithNestedArgs2]
# More complex path to subtype type variable
class A<T>: pass
class B<T>(A<C<X, A<T>>>):
    void f(self, T a, any d):
        a = d
class C<S, T>: pass
class X: pass
[out]
...
class B(A):
...
    void f(B self, any* a, any d):
        a = {self.__tv.args[1].args[0] d}
...

[case testGenericInheritanceMultipleLevels]
# Two levels of inheritance
class A<T>:
    void f(self, T t):
        pass
class B(A<int>): pass
class C<T>(B):
    void g(self, T t, any d):
        self.f(d)
        t = d
[out]
...
class C(B):
...
    void g(C self, any* t, any d):
        self.f({int d})
        t = {self.__tv2 d}
...


-- Constructors with generic inheritance
-- -------------------------------------


-- 1. Wrapper that calls superclass __init__


[case testInheritingGenericClassWithDefaultConstructor]
class A<T>: pass
class B(A<int>): pass
[out]
...
class B(A):
    void __init__(B self):
        self.__tv! = <int>
        super().__init__(<int>)
...

[case testInheritingGenericClassWithDefaultConstructor2]
# Two type arguments
class A<T, S>: pass
class B(A<int, object>): pass
[out]
...
class B(A):
    void __init__(B self):
        self.__tv! = <int>
        self.__tv2! = <object>
        super().__init__(<int>, <object>)
...

[case testInheritingGenericClassWithNonDefaultConstructor-skip]
class A<T>:
    void __init__(self, object o):
        pass
class B(A<int>): pass
[out]
...
class B(A):
    void __init__(B self, object o):
        self.__tv! = <int>
        super().__init__(<int>, o)
...

[case testInheritingGenericClassWithNonDefaultConstructor2-skip]
# Two arguments, one with tvar type
class A<T>:
    void __init__(self, T t, object o):
        pass
class B(A<int>): pass
[out]
...
class B is A<Int>
  def create(t as Int, o as Object)
    self.__tv = <int>
    super.create(<int>, t, o)
  end
end

[case testInheritingGenericClassFromNonGenericWithDefaultConstructor-skip]
class A: pass
class B<T>(A): pass
[out]
...
class B<T> is A
  var __tv as dynamic
  def create(__tv as dynamic)
    self.__tv = <__tv>
    super.create()
  end
...

[case testInheritingGenericClassFromNonGenericWithDefaultConstructor2-skip]
# Superclass defines a non-trivial constructor; two tvars
class A:
    void __init__(self, int n):
        pass
class B<T, S>(A): pass
[out]
...
class B<T, S> is A
  var __tv as dynamic
  var __tv2 as dynamic
  def create(__tv as dynamic, __tv2 as dynamic, n as Int)
    self.__tv = <__tv>
    self.__tv2 = <__tv2>
    super.create(n)
  end
...

[case testInheritingGenericClassFromGenericWithDefaultConstructor-skip]
class A<T, S>: pass
class B<U>(A<int, C<U>>): pass
class C<T>: pass
[out]
...
class B<U> is A<Int, C<U>>
  def create(__tv as dynamic)
    self.__tv = <int>
    self.__tv2 = <C<__tv>>
    super.create(<int>, <C<__tv>>)
  end
...

[case testInitWrapperWithDeepHierarchy-skip]
class A<T>: pass
class B(A<int>): pass
class C<T>(B): pass
[out]
...
class C<T> is B
  var __tv2 as dynamic
  def create(__tv as dynamic)
    self.__tv = <int>
    self.__tv2 = <__tv>
    super.create()
  end
...

[case testInitWrapperWithDeepHierarchy2-skip]
class A: pass
class B(A): pass
class C<T>(B): pass
[out]
...
class C<T> is B
  var __tv as dynamic
  def create(__tv as dynamic)
    self.__tv = <__tv>
    super.create()
  end
...

[case testInitWrapperWithDefaultInitializer-skip]
class A:
    int n
    
    void __init__(self, int n):
        self.n = n
class B<T>(A): pass
[out]
...
class B<T> is A
  var __tv as dynamic
  def create(__tv as dynamic, n as Int)
    self.__tv = <__tv>
    super.create(n)
  end
...


-- 2. Define new constructor in subclass


[case testInitWithGenericInheritance-skip]
class A<T, U>: pass
class B<S>(A<int, S>):
    void __init__(self, int n):
        pass
[out]
...
class B<S> is A<Int, S>
  def create(__tv as dynamic, n as Int)
    self.__tv = <int>
    self.__tv2 = <__tv>
  end
...


-- Constructor in a wrapper class; generic inheritance
-- ---------------------------------------------------


[case testInitInWrapperClassWithGenericInheritance-skip]
# Generic class inherits another generic class
class A<T, S>: pass
class B<U>(A<int, C<U>>): pass
class C<T>: pass
[out]
...
class B* is A*
  def create(__o as dynamic, __tv as dynamic, __tv2 as dynamic, __btv as dynamic, __btv2 as dynamic)
    self.__tv = <__tv>
    self.__tv2 = <__tv2>
    self.__btv = <__btv>
    self.__btv2 = <__btv2>
    self.__o = __o
  end
...

[case testInitInWrapperClassWithInheritance2-skip]
# Original create has arguments; this does not affect the wrapper
class A<T>:
    void __init__(self, int n):
        pass
class B<T>(A<T>): pass
class C<T>: pass
[out]
...
class B* is A*
  def create(__o as dynamic, __tv as dynamic, __btv as dynamic)
...

[case testInitInWrapperClassWithInheritance3-skip]
# Multi-level inheritance hierarchy; note that there is no wrapper class
# for B.
class A<T>: pass
class B(A<int>): pass
class C<T, S>(B): pass
[out]
...
class C* is A*
  var __tv2 as dynamic
  var __tv3 as dynamic
  var __btv2 as dynamic
  var __btv3 as dynamic
  def create(__o as dynamic, __tv as dynamic, __tv2 as dynamic, \
                             __tv3 as dynamic, __btv as dynamic, \
                             __btv2 as dynamic, __btv3 as dynamic)
    self.__tv = <__tv>
    self.__tv2 = <__tv2>
    self.__tv3 = <__tv3>
    self.__btv = <__btv>
    self.__btv2 = <__btv2>
    self.__btv3 = <__btv3>
    self.__o = __o
  end
end


-- Type variable definitions in subclasses; generic inheritance
-- ------------------------------------------------------------


[case testTvarDefinitionsWithGenericInheritance-skip]
# Generic class inherits generic class; no new type variables
class A<T>: pass
class B<T>(A<T>): pass
[out]
...
class B<T> is A<T>
  def create(__tv as dynamic)
...
class B* is A*
  def create(__o as dynamic, __tv as dynamic, __btv as dynamic)
...

[case testTvarDefinitionsWithGenericInheritance-skip]
# Generic class inherits generic class; introduce new type variable
class A<T>: pass
class B<S, T>(A<T>): pass
[out]
...
class B<S, T> is A<T>
  var __tv2 as dynamic
  def create(__tv as dynamic, __tv2 as dynamic)
...
class B* is A*
  var __tv2 as dynamic
  var __btv2 as dynamic
  def create(__o as dynamic, __tv as dynamic, __tv2 as dynamic, \
                                          __btv as dynamic, __btv2 as dynamic)
...


-- Calling superclass create explicitly
-- ------------------------------------


[case testGenericInheritanceAndCallToSuperclassInit]
# Non-generic class inherits a generic class
class A<T>:
    void __init__(self, C n):
        pass

class C: pass

class B(A<int>):
    void __init__(self):
        super().__init__(C())
[out]
...
class B(A):
    void __init__(B self):
        self.__tv! = <int>
        super().__init__(<int>, C())
...

[case testGenericInheritanceAndCallToSuperclassInit2-skip]
# Non-generic class inherits a generic class
class A<T>: pass

class B(A<int>):
    void __init__(self):
        super().__init__()
[out]
...
class B is A<Int>
  def create() as void
    self.__tv = <int>
-- FIX should be    super.create(<int>)
    super.create()
  end
end


[case testGenericInheritanceAndCallToSuperclassInit-skip]
# Generic class inherits a generic class
class A<T, S>:
    void __init__(self, T t):
        pass

class B<T, S>(A<S, T>):
    void __init__(self, S t):
        super().__init__(t)
[out]
...
class B<T, S> is A<S, T>
  def create(__tv as dynamic, __tv2 as dynamic, t as S)
    self.__tv = <__tv2>
    self.__tv2 = <__tv>
    super.create(<__tv2>, <__tv>, t)
  end
...


-- Mixed generic inheritance
-- -------------------------


[case testMixedGenericInheritance-skip]
# Non-generic class extends generic
class A<T>:
    T f(self, T t):
        pass
class B(A<int>):
    any f(self, any t):
        pass
[out]
...
class B is A<Int>
  def f`B(t as dynamic) as dynamic
  end
  def f(t as dynamic) as dynamic
    return {int <= any | f`B({any <= int | t})}
  end
  def f*(t as dynamic) as dynamic
    return f`B(t)
  end
...

[case testMixedGenericInheritance2-skip]
# Generic class extends generic
class A<T>:
    T f(self, T t):
        pass
class B<T, S>(A<S>):
    any f(self, any t):
        pass
[out]
...
class B<T, S> is A<S>
  var __tv2 as dynamic
  def f`B(t as dynamic) as dynamic
  end
  def f(t as dynamic) as dynamic
    return {self.__tv <= any | f`B(t)}
  end
  def f*(t as dynamic) as dynamic
    return f`B(t)
  end
...
class B* is A*
...
  def f`B(t as dynamic) as dynamic
    return self.__o.f`B(t)
  end
  def f*(t as dynamic) as dynamic
    return self.__o.f`B(t)
  end
end


-- Generic inheritance with multiple ways of accessing subclass tvars
-- ------------------------------------------------------------------


-- Example: class C<T>(D<T, T>) ...


[case testAmbiguousTvarMappingAndGenericInheritance-skip]
class D<T, S>:
    S f(self):
        pass
class C<T>(D<T, T>):
    T f(self):
        pass
[out]
...
class C<T> is D<T, T>
...
  def create(__tv as dynamic)
    self.__tv = <__tv>
    self.__tv2 = <__tv>
    super.create(<__tv>, <__tv>)
  end
end
class C* is D*
  def create(__o as dynamic, __tv as dynamic, __tv2 as dynamic, \
                                      __btv as dynamic, __btv2 as dynamic)
    self.__tv = <__tv>
    self.__tv2 = <__tv2>
    self.__btv = <__btv>
    self.__btv2 = <__btv2>
    self.__o = __o
  end
  def f`C() as dynamic
    return {self.__tv <= self.__btv | {self.__btv <= self.__o.__tv | self.__o.f`C()}}
  end
  def f*() as dynamic
    return {self.__btv <= self.__o.__tv | self.__o.f`C()}
  end
end


-- Generic inheritance + member variables
-- --------------------------------------


[case testMemberVarsAndGenericInheritance-skip]
class A<T>:
    T x
    void f(self, any a):
        self.x = a
        a = self.x
class B<T>(A<C<T>>):
    T y
    void g(self, any a):
        self.y = a
        a = self.y

class C<T>: pass
[out]
class A<T>
  var __tv as dynamic
  private var x as T
  def f(a as dynamic)
    x = {self.__tv <= any | a}
    a = x
  end
...
class A*
  var __o as dynamic
  var __tv as dynamic
  var __btv as dynamic
  def create(__o as dynamic, __tv as dynamic, __btv as dynamic)
    self.__tv = <__tv>
    self.__btv = <__btv>
    self.__o = __o
  end
  def f(a as dynamic)
    self.__o.f(a)
  end
  def f*(a as dynamic) as dynamic
    self.__o.f(a)
  end
end
class B<T> is A<C<T>>
  private var y as T
  def g(a as dynamic)
    y = {self.__tv.args[0] <= any | a}
    a = y
  end
...
