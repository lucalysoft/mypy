-- Test cases for runtime (dynamic) checking transformation.
--
-- Each test case consists of at least two sections.
-- The first section contains [case NAME] followed by the input code, while
-- the second section contains [out] followed by the output from the
-- transformation.

-- Note that the test cases use a pretty-printed output syntax that is not
-- valid Alore code.


-- Generics basics
-- ---------------


[case testSimplestGenericClass]
from typing import typevar, Generic
T = typevar('T')
class C(Generic[T]): pass
[out]
class C:
    any __tv
    void __init__(C self, any __tv):
        self.__tv! = <__tv>
any C*():
    return C(<any>)
class C**:
    any __o
    any __tv
    any __btv
    void __init__(any self, any __o, any __tv, any __btv):
        self.__tv! = <__tv>
        self.__btv! = <__btv>
        self.__o! = __o

[case testSimpleGenericClass]
from typing import typevar, Generic, Undefined
T = typevar('T')
class C(Generic[T]):
    o = Undefined # type: T
    def __init__(self, o: T) -> None:
        self.o = o
    def get(self) -> T:
        return self.o
    def num(self) -> int:
        return 1
[out]
class C:
    any __tv
    any* o
    any* $o(C self):
        return self.o!
    void set$o(C self, any* o):
        self.o! = o
    any $o*(C self):
        return self.o!
    void set$o*(C self, any o):
        self.o! = {self.__tv o}
    void __init__(C self, any __tv, any* o):
        self.__tv! = <__tv>
        self.o = o
    any* get(C self):
        return self.o
    any get*(any self):
        return {C<self.__tv> self}.get()
    int num(C self):
        return 1
    any num*(any self):
        return {any <= int {C<self.__tv> self}.num()}
any C*(any o):
    return C(<any>, o)
class C**:
    any __o
    any __tv
    any __btv
    void __init__(any self, any __o, any __tv, any __btv):
        self.__tv! = <__tv>
        self.__btv! = <__btv>
        self.__o! = __o
    any $o(C self):
        return {self.__tv {self.__btv self.__o.$o()}}
    any $o*(any self):
        return {self.__btv self.__o.$o()}
    void set$o(C self, any o):
        self.__o.set$o({self.__o.__tv {self.__btv o}})
    any set$o*(any self, any o):
        self.__o.set$o({self.__o.__tv {self.__btv o}})
    any get(C self):
        return {self.__tv {self.__btv self.__o.get()}}
    any get*(any self):
        return {self.__btv self.__o.get()}
    int num(C self):
        return self.__o.num()
    any num*(any self):
        return {any <= int self.__o.num()}

[case testGenericMethodWithArguments]
from typing import typevar, Generic
T = typevar('T')
class C(Generic[T]):
    def f(self, a: 'A', t: T) -> None:
        pass
class A: pass
[out]
class C:
    any __tv
    void f(C self, A a, any* t):
        pass
    any f*(any self, any a, any t):
        {C<self.__tv> self}.f({A a}, {self.__tv t})
...
class C**:
...
    void f(C self, A a, any t):
        self.__o.f(a, {self.__o.__tv {self.__btv t}})
    any f*(any self, any a, any t):
        self.__o.f({A a}, {self.__o.__tv {self.__btv t}})
...

[case testAccessingGenericClassMethodInTypedContext]
from typing import typevar, Generic, Undefined, Any
T = typevar('T')
class A: pass
class B: pass
class C(Generic[T]):
    def __init__(self) -> None:
        pass
    def f(self, a: A) -> None:
        pass
c = Undefined # type: C[B]
c.f(Any(A()))
[out]
...
C c
c.f({A (any)A()})

[case testAccessingMethodInGenericClassAndTypedContextViaSelf]
from typing import typevar, Generic
T = typevar('T')
class A: pass
class C(Generic[T]):
    def f(self, a: A) -> None:
        self.f(a)
[out]
...
    void f(C self, A a):
        self.f(a)
...

[case testConstructingGenericInstance]
from typing import typevar, Generic, Any
T = typevar('T')
class C(Generic[T]):
    def __init__(self) -> None:
        pass
class A: pass
a = C[A]() # type: C[A]
d = C[Any]() # type: C[Any]
[out]
...
class A:
...
C a = C(<A>)
C d = C(<any>)

[case testConstructingGenericInstanceWithGenericArg]
from typing import typevar, Generic
T = typevar('T')
class C(Generic[T]):
    def __init__(self) -> None:
        pass
class A: pass
a = C[C[A]]() # type: C[C[A]]
[out]
...
class A:
...
C a = C(<C<A>>)

[case testCastFromAnyToGenericType]
from typing import typevar, Generic, Undefined, Any
T = typevar('T')
class A(Generic[T]):
    a = Undefined # type: T
    def __init__(self, a: T) -> None:
        self.a = a
    def f(self) -> T:
        return self.a
class B: pass
class C: pass
d = A[Any](B()) # type: Any
b = Undefined # type: B
b = d.f()
aa = d # type: A[C]
aa.f()             # Failure at runtime
[out]
...
any d = A(<any>, B())
B b
b = {B d.f*()}
A aa = {A<C> d}
aa.f()

[case testCastWithDynamicAndTypedArguments]
from typing import typevar, Generic, Undefined, Any
T = typevar('T')
class A(Generic[T]): pass
class B: pass
a = Undefined # type: A[B]
d = Undefined # type: A[Any]
a = d
d = a
[out]
...
A d
a = {A<B> d}
d = {A<any> a}

[case testNestedGenerics]
from typing import typevar, Generic, Undefined, Any
T = typevar('T')
class A(Generic[T]):
    def f(self) -> None:
        pass
class B: pass
a = Undefined # type: A[A[B]]
d = Undefined # type: A[Any]
d = a
a = d
a.f()
d.f()
[out]
...
A d
d = {A<any> a}
a = {A<A<B>> d}
a.f()
d.f()

[case testGenericWrapperWithNonGenericTypesInSignatures]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]):
    def f(self, b: 'B', ab: 'A[B]') -> 'A[B]':
        pass
    def g(self) -> 'B':
        pass
class B: pass
[out]
...
class A**:
...
    any f*(any self, any b, any ab):
        return self.__o.f({B b}, {A<B> ab})
...
    any g*(any self):
        return self.__o.g()
...


-- Multiple type arguments
-- -----------------------


[case testSimplestClassWithTwoTypeArguments]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
class A(Generic[T, S]): pass
[out]
class A:
    any __tv
    any __tv2
    void __init__(A self, any __tv, any __tv2):
        self.__tv! = <__tv>
        self.__tv2! = <__tv2>
any A*():
    return A(<any>, <any>)
class A**:
    any __o
    any __tv
    any __tv2
    any __btv
    any __btv2
    void __init__(any self, any __o, any __tv, any __tv2, any __btv, any __btv2):
        self.__tv! = <__tv>
        self.__tv2! = <__tv2>
        self.__btv! = <__btv>
        self.__btv2! = <__btv2>
        self.__o! = __o

[case testConstructingInstanceWithTwoTypeArguments]
from typing import typevar, Generic, Undefined
T = typevar('T')
S = typevar('S')
class A(Generic[T, S]): pass
a = Undefined # type: A[int, float]
a = A[int, float]()
[out]
...
A a
a = A(<int>, <float>)

[case testCallingEmptyMethodWithTwoTypeArguments]
from typing import typevar, Generic, Undefined
T = typevar('T')
S = typevar('S')
class A(Generic[T, S]):
    def f(self) -> None:
        pass
class B: pass
class C: pass

a = Undefined # type: A[B, C]
a.f()
[out]
...
    any f*(any self):
        {A<self.__tv, self.__tv2> self}.f()
...
class A**:
...
    void f(A self):
        self.__o.f()
    any f*(any self):
        self.__o.f()
...
A a
a.f()

[case testAccessingMultipleTypeArguments]
from typing import typevar, Generic, Undefined
T = typevar('T')
S = typevar('S')
class A(Generic[T, S]):
    x = Undefined # type: T
    def f(self, y: S) -> T:
        return self.x
[out]
...
class A**:
...
    any f(A self, any y):
        return {self.__tv {self.__btv self.__o.f(\
                                    {self.__o.__tv2 {self.__btv2 y}})}}
    any f*(any self, any y):
        return {self.__btv self.__o.f({self.__o.__tv2 {self.__btv2 y}})}
...

[case testAccessingGenericMethodInTypedContextViaSelfAndMultipleArgs]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
class A: pass
class B: pass
class C(Generic[T, S]):
    def f(self, a: A) -> None:
        self.f(a)
[out]
...
    void f(C self, A a):
        self.f(a)
...


-- Coercions involving type variables
-- ----------------------------------


-- NOTE: Some of the wrapper test cases above also coerce to/from type
--       variables.


[case testSimpleTypeVarCoercionWithMultipleTypeVariables]
from typing import typevar, Generic, Undefined, Any
T = typevar('T')
S = typevar('S')
class A(Generic[T, S]):
    t = Undefined # type: T
    s = Undefined # type: S
    def f(self) -> None:
        d = Undefined # type: Any
        d = self.t
        self.t = d
        self.s = d
[out]
...
    void f(A self):
        any d
        d = self.t
        self.t = {self.__tv d}
        self.s = {self.__tv2 d}
...

[case testTypeVarCoercionsWithGenericTypes]
from typing import typevar, Generic, Undefined, Any
T = typevar('T')
class A(Generic[T]):
    a = Undefined # type: A[T]
    def f(self) -> None:
        d = Undefined # type: Any
        d = self.a
        self.a = d
[out]
...
    void f(A self):
        any d
        d = self.a
        self.a = {A<self.__tv> d}
...

[case testConstructGenericInstanceBasedOnTypeVar]
from typing import typevar, Generic, Undefined, Any
T = typevar('T')
class A(Generic[T]):
    def f(self) -> None:
        a = A[T]()
        d = Undefined # type: Any
        a = d
[out]
...
    void f(A self):
        a = A(<self.__tv>)
        any d
        a = {A<self.__tv> d}
...


-- Type erasure
-- ------------


[case testTypeErasureOfFunctionSignatures]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]): pass
class B:
    def m(self, a: 'A[B]') -> None:
        pass
def f() -> A[B]:
    pass
[out]
...
class B:
    void m(B self, A a):
        pass
    any m*(any self, any a):
        {B self}.m({A<B> a})
any B*():
    return B()
A f():
    pass


-- Generic functions
-- -----------------


[case testSimpleGenericFunction]
from typing import typevar
T = typevar('T')
def f(x: T) -> T:
    return x
[out]
any* f(any __ftv, any* x):
    return x

[case testGenericFunctionWithTwoTvars]
from typing import typevar
T = typevar('T')
S = typevar('S')
def f(x: T) -> T:
    return x
[out]
any* f(any __ftv, any __ftv2, any* x):
    return x

[case testCallingSimpleGenericFunction]
from typing import typevar, Any
T = typevar('T')
def f(x: T) -> T:
    return x
def g() -> None:
    c = C() # type: C
    c = f['C'](c)
    d = c # type: Any
    d = f['C'](d)
    c = f[Any](c)

class C: pass
class D: pass
[out]
...
void g():
    C c = C()
    c = f(<C>, c)
    any d = c
    d = f(<C>, {C d})
    c = {C f(<any>, c)}
...

[case testTypeVarReferenceInGenericFunction]
from typing import typevar, Any, Generic
T = typevar('T')
def f(x: Any) -> 'C[T]':
    a = C[T]()
    f[T](x)
    return x

class C(Generic[T]): pass
[out]
C f(any __ftv, any x):
    a = C(<__ftv>)
    f(<__ftv>, x)
    return {C<__ftv> x}
...


-- Generic methods
-- ---------------


[case testSimpleGenericMethod]
from typing import typevar
T = typevar('T')
class A:
    def f(self, x: T) -> T:
        return x
[out]
class A:
    any* f(A self, any __ftv, any* x):
        return x
    any f*(any self, any x):
        return {A self}.f(<any>, x)
...

[case testGenericMethodInGenericClass]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
class A(Generic[T]):
    def f(self, x: S) -> S:
        return x
[out]
class A:
    any __tv
    any* f(A self, any __ftv, any* x):
        return x
    any f*(any self, any x):
        return {A<self.__tv> self}.f(<any>, x)
    void __init__(A self, any __tv):
        self.__tv! = <__tv>
any A*():
    return A(<any>)
class A**:
    any __o
    any __tv
    any __btv
    void __init__(any self, any __o, any __tv, any __btv):
        self.__tv! = <__tv>
        self.__btv! = <__btv>
        self.__o! = __o
    any f(any __ftv, A self, any x):
        return self.__o.f(<__ftv>, x)
    any f*(any self, any x):
        return self.__o.f(<any>, x)

[case testCalllingGenericMethod]
from typing import typevar
T = typevar('T')
class A:
    def f(self) -> T:
        pass
    def g(self) -> 'C':
        return self.f['C']()
c = A().f['C']() # type: C
class C: pass
[out]
...
    C g(A self):
        return self.f(<C>)
...
C c = A().f(<C>)
...

[case testCalllingGenericMethod2]
from typing import typevar, Generic
S = typevar('S')
T = typevar('T')
class A(Generic[S]):
    def f(self) -> T:
        pass
    def g(self) -> S:
        return self.f[S]()
c = (A['D']()).f['C']() # type: C
class C: pass
class D: pass
[out]
...
    any* g(A self):
        return self.f(<self.__tv>)
...
C c = (A(<D>)).f(<C>)
...

[case testAccessingGenericMethodTvars]
from typing import typevar, Generic
S = typevar('S')
T = typevar('T')
U = typevar('U')
class A(Generic[S]):
    def f(self) -> 'C[T, U, S]':
        return C[T, U, S]()
class C(Generic[T, S, U]): pass
[out]
...
    C f(A self, any __ftv, any __ftv2):
        return C(<__ftv>, <__ftv2>, <self.__tv>)
    any f*(any self):
        return {A<self.__tv> self}.f(<any>, <any>)
...
class A**:
...
    C f(any __ftv, any __ftv2, A self):
        return {C<__ftv, __ftv2, self.__tv> {C<__ftv, __ftv2, self.__btv> \
                                               self.__o.f(<__ftv>, <__ftv2>)}}
    any f*(any self):
        return {C<any, any, self.__btv> self.__o.f(<any>, <any>)}
...


-- Dynamically typed functions
-- ---------------------------


[case testCallGenericTypeInDynamicallyTypedFunction]
from typing import typevar, Generic
T = typevar('T')
def f():
    A()
class A(Generic[T]):
    pass
[out]
any f():
    A(<any>)
...


-- Misc test cases
-- ---------------


[case testPairExample]
from typing import typevar, Generic, Undefined
H = typevar('H')
T = typevar('T')
# This test case is adapted from an early example program.
class P(Generic[H, T]):
    head = Undefined # type: H
    tail = Undefined # type: T
    name = Undefined # type: Name
    def __init__(self, head: H, tail: T, name: 'Name') -> None:
        self.head = head
        self.tail = tail
        self.name = name
    def set_head(self, new_head: H, new_name: 'Name') -> 'P[H, T]':
        return P[H, T](new_head, self.tail, new_name)
class Name: pass
[out]
class P:
...
    P set_head(P self, any* new_head, Name new_name):
        return P(<self.__tv>, <self.__tv2>, new_head, self.tail, new_name)
    any set_head*(any self, any new_head, any new_name):
        return {P<self.__tv, self.__tv2> self}.set_head(\
                                  {self.__tv new_head}, {Name new_name})
any P*(any head, any tail, any name):
    return P(<any>, <any>, head, tail, {Name name})
class P**:
...
    P set_head(P self, any new_head, Name new_name):
        return {P<self.__tv, self.__tv2> \
                 {P<self.__btv, self.__btv2> self.__o.set_head(\
                         {self.__o.__tv {self.__btv new_head}}, new_name)}}
    any set_head*(any self, any new_head, any new_name):
        return {P<self.__btv, self.__btv2> self.__o.set_head(\
                       {self.__o.__tv {self.__btv new_head}}, {Name new_name})}
class Name:
    pass
...

[case testImplicitMethodSigInGenericClass]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]):
    def f(self, a):
        pass
    def g(self) -> None:
        i = self.f(1) # type: int
        j = self.f(1) # type: int
[out]
...
class A**:
...
    any f(any self, any a):
        return self.__o.f(a)
    any f*(any self, any a):
        return self.__o.f(a)
...
