-- Test cases for intermediate representation (icode) generation.
--
-- Only functions mentioned in the [out] section are checked; others are 
-- ignored.
--
-- There is no register sharing. Each temporary value is given a new register.


-- The very basics
-- ---------------


[case testEmptyFunction]
void f(): pass
[out]
def f:
    r0 = None
    return r0

[case testReturnIntLiteral]
int f():
    return 2
[out]
def f:
    r0 = 2
    return r0
    
[case testAssignAndReturnLocalVar]
int f():
    i = 2
    return i
[out]
def f:
    r0 = 2
    r1 = r0
    return r1
    
[case testAssignTwice]
int f():
    i = 2
    i = 3
    return i
[out]
def f:
    r0 = 2
    r1 = r0
    r2 = 3
    r1 = r2
    return r1
    
[case testFunctionArgs]
int f(int a, int b):
    c = a
    a = b
    return a
[out]
def f:
    r2 = r0
    r0 = r1
    return r0


-- Conditionals and loops
-- ----------------------


[case testSimpleWhileLoop]
void f():
    i = 0
    while i < 100:
        i = i + 1
[out]
def f:
    r0 = 0
    r1 = r0
L1:
    r2 = 100
    if r1 < r2 goto L2 else goto L3
L2:
    r3 = 1
    r4 = r1 + r3 [int]
    r1 = r4
    goto L1
L3:
    r5 = None
    return r5

[case testIfWithoutElse]
void f():
    if 2 < 3:
        i = 1
[out]
def f:
    r0 = 2
    r1 = 3
    if r0 < r1 goto L1 else goto L2
L1:
    r2 = 1
    r3 = r2
L2:
    r4 = None
    return r4

[case testIfWithElse]
int f():
    if 2 < 3:
        i = 1
    else:
        i = 2
[out]
def f:
    r0 = 2
    r1 = 3
    if r0 < r1 goto L1 else goto L2
L1:
    r2 = 1
    r3 = r2
    goto L3
L2:
    r4 = 2
    r3 = r4
L3:
    r5 = None
    return r5


-- Arithmetic expressions
-- ----------------------


[case testComplexArithmeticExpression]
int f():
    return 3 * (1 + 2) - 4
[out]
def f:
    r0 = 3
    r1 = 1
    r2 = 2
    r3 = r1 + r2 [int]
    r4 = r0 * r3 [int]
    r5 = 4
    r6 = r4 - r5 [int]
    return r6
    
[case testUnaryExpression]
int f():
    return -1 + -(2 + 3)
[out]
def f:
    r0 = 1
    r1 = -r0 [int]
    r2 = 2
    r3 = 3
    r4 = r2 + r3 [int]
    r5 = -r4 [int]
    r6 = r1 + r5 [int]
    return r6


-- Boolean expressions
-- -------------------


[case testBooleanAnd]
void f():
    if 1 == 2 and 3 > 4:
        i = 1
[out]
def f:
    r0 = 1
    r1 = 2
    if r0 == r1 goto L1 else goto L3
L1:
    r2 = 3
    r3 = 4
    if r2 > r3 goto L2 else goto L3
L2:
    r4 = 1
    r5 = r4
L3:
    r6 = None
    return r6
    
[case testBooleanOr]
void f():
    if 1 == 2 or 3 > 4:
        i = 1
[out]
def f:
    r0 = 1
    r1 = 2
    if r0 == r1 goto L2 else goto L1
L1:
    r2 = 3
    r3 = 4
    if r2 > r3 goto L2 else goto L3
L2:
    r4 = 1
    r5 = r4
L3:
    r6 = None
    return r6
    
[case testSimpleBooleanNot]
void f():
    if not 1 == 2:
        i = 1
[out]
def f:
    r0 = 1
    r1 = 2
    if r0 != r1 goto L1 else goto L2
L1:
    r2 = 1
    r3 = r2
L2:
    r4 = None
    return r4
    
[case testNotAnd]
void f():
    if not (1 == 2 and 3 == 4):
        i = 1
[out]
def f:
    r0 = 1
    r1 = 2
    if r0 != r1 goto L2 else goto L1
L1:
    r2 = 3
    r3 = 4
    if r2 != r3 goto L2 else goto L3
L2:
    r4 = 1
    r5 = r4
L3:
    r6 = None
    return r6
      
[case testNotOr]
void f():
    if not (1 == 2 or 3 == 4):
        i = 1
[out]
def f:
    r0 = 1
    r1 = 2
    if r0 != r1 goto L1 else goto L3
L1:
    r2 = 3
    r3 = 4
    if r2 != r3 goto L2 else goto L3
L2:
    r4 = 1
    r5 = r4
L3:
    r6 = None
    return r6


-- Calls
-- -----


[case testCallFunctionWithoutArgs]
int f():
    return f()
[out]
def f:
    r0 = f()
    return r0
    
[case testCallWithArgument]
void f(int a):
    f(a + 1)
[out]
def f:
    r1 = 1
    r2 = r0 + r1 [int]
    r3 = f(r2)
    r4 = None
    return r4

[case testCallWithArguments]
int f(int a, int b):
    return f(2, a + 1)
[out]
def f:
    r2 = 2
    r3 = 1
    r4 = r0 + r3 [int]
    r5 = f(r2, r4)
    return r5


-- Top level
-- ---------


[case testTopLevel]
f()
int f():
    return 1
f()
[out]
def __init:
    r0 = f()
    r1 = f()
    r2 = None
    return r2
def f:
    r0 = 1
    return r0
