-- Test cases for intermediate representation (icode) generation.
--
-- Only functions mentioned in the [out] section are checked; others are 
-- ignored.
--
-- There is no register sharing. Each temporary value is given a new register.


-- The very basics
-- ---------------


[case testEmptyFunction]
void f(): pass
[out]
def f:
    r0 = None
    return r0

[case testReturnIntLiteral]
int f():
    return 2
[out]
def f:
    r0 = 2
    return r0
    
[case testAssignAndReturnLocalVar]
int f():
    i = 2
    return i
[out]
def f:
    r0 = 2
    r1 = r0
    return r1
    
[case testAssignTwice]
int f():
    i = 2
    i = 3
    return i
[out]
def f:
    r0 = 2
    r1 = r0
    r2 = 3
    r1 = r2
    return r1
    
[case testFunctionArgs]
int f(int a, int b):
    c = a
    a = b
    return a
[out]
def f:
    r2 = r0
    r0 = r1
    return r0


-- Conditionals and loops
-- ----------------------


[case testSimpleWhileLoop]
void f():
    i = 0
    while i < 100:
        i = i + 1
[out]
def f:
    r0 = 0
    r1 = r0
L1:
    if r1 < 100 goto L2 else goto L3
L2:
    r2 = r1 + 1 [int]
    r1 = r2
    goto L1
L3:
    r3 = None
    return r3

[case testIfWithoutElse]
void f():
    if 2 < 3:
        i = 1
[out]
def f:
    if 2 < 3 goto L1 else goto L2
L1:
    r0 = 1
    r1 = r0
L2:
    r2 = None
    return r2

[case testIfWithElse]
int f():
    if 2 < 3:
        i = 1
    else:
        i = 2
[out]
def f:
    if 2 < 3 goto L1 else goto L2
L1:
    r0 = 1
    r1 = r0
    goto L3
L2:
    r2 = 2
    r1 = r2
L3:
    r3 = None
    return r3


-- Arithmetic expressions
-- ----------------------


[case testComplexArithmeticExpression]
int f():
    return 3 * (1 + 2) - 4
[out]
def f:
    r0 = 1 + 2 [int]
    r1 = 3 * r0 [int]
    r2 = r1 - 4 [int]
    return r2
    
[case testUnaryExpression]
int f():
    return -1 + -(4 + 5)
[out]
def f:
    r0 = 1
    r1 = -r0 [int]
    r2 = 4 + 5 [int]
    r3 = -r2 [int]
    r4 = r1 + r3 [int]
    return r4


-- Boolean expressions
-- -------------------


[case testBooleanAnd]
void f():
    if 1 == 2 and 3 > 4:
        i = 1
[out]
def f:
    if 1 == 2 goto L1 else goto L3
L1:
    if 3 > 4 goto L2 else goto L3
L2:
    r0 = 1
    r1 = r0
L3:
    r2 = None
    return r2
    
[case testBooleanOr]
void f():
    if 1 == 2 or 3 > 4:
        i = 1
[out]
def f:
    if 1 == 2 goto L2 else goto L1
L1:
    if 3 > 4 goto L2 else goto L3
L2:
    r0 = 1
    r1 = r0
L3:
    r2 = None
    return r2
    
[case testSimpleBooleanNot]
void f():
    if not 1 == 2:
        i = 1
[out]
def f:
    if 1 != 2 goto L1 else goto L2
L1:
    r0 = 1
    r1 = r0
L2:
    r2 = None
    return r2
    
[case testNotAnd]
void f():
    if not (1 == 2 and 3 == 4):
        i = 1
[out]
def f:
    if 1 != 2 goto L2 else goto L1
L1:
    if 3 != 4 goto L2 else goto L3
L2:
    r0 = 1
    r1 = r0
L3:
    r2 = None
    return r2

[case testNotOr]
void f():
    if not (1 == 2 or 3 == 4):
        i = 1
[out]
def f:
    if 1 != 2 goto L1 else goto L3
L1:
    if 3 != 4 goto L2 else goto L3
L2:
    r0 = 1
    r1 = r0
L3:
    r2 = None
    return r2


-- Calls
-- -----


[case testCallFunctionWithoutArgs]
int f():
    return f()
[out]
def f:
    r0 = f()
    return r0
    
[case testCallWithArgument]
void f(int a):
    f(a + 1)
[out]
def f:
    r1 = r0 + 1 [int]
    r2 = f(r1)
    r3 = None
    return r3

[case testCallWithArguments]
int f(int a, int b):
    return f(2, a + 1)
[out]
def f:
    r2 = 2
    r3 = r0 + 1 [int]
    r4 = f(r2, r3)
    return r4


-- Top level
-- ---------


[case testTopLevel]
f()
int f():
    return 1
f()
[out]
def __init:
    r0 = f()
    r1 = f()
    r2 = None
    return r2
def f:
    r0 = 1
    return r0
