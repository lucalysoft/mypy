-- Simple generic types
-- --------------------


[case testGenericMethodReturnType]
from typing import Undefined, typevar, Generic
T = typevar('T')
a, b, c = Undefined, Undefined, Undefined # type: (A[B], B, C)
c = a.f() # Fail
b = a.f()

class A(Generic[T]):
    def f(self) -> T: pass

class B: pass
class C: pass
[out]
main, line 4: Incompatible types in assignment

[case testGenericMethodArgument]
from typing import Undefined, typevar, Generic
T = typevar('T')
a.f(c) # Fail
a.f(b)

a = Undefined # type: A[B]
b = Undefined # type: B
c = Undefined # type: C

class A(Generic[T]):
    def f(self, a: T) -> None: pass

class B: pass
class C: pass
[out]
main, line 3: Argument 1 to "f" of "A" has incompatible type "C"

[case testGenericMemberVariable]
from typing import typevar, Generic, Undefined
T = typevar('T')
class A(Generic[T]):
    def __init__(self, v: T) -> None:
        self.v = v
        
a, b, c = Undefined, Undefined, Undefined # type: (A[B], B, C)
a.v = c # Fail
a.v = b

class B: pass
class C: pass
[out]
main, line 8: Incompatible types in assignment

[case testGenericMemberVariable]
from typing import Undefined, typevar, Generic
T = typevar('T')
a, b, c = Undefined, Undefined, Undefined # type: (A[B], B, C)
a.v = c # Fail
a.v = b

class A(Generic[T]):
    v = Undefined # type: T
class B: pass
class C: pass
[out]
main, line 4: Incompatible types in assignment

[case testSimpleGenericSubtyping]
from typing import Undefined, typevar, Generic
T = typevar('T')
b, bb, c = Undefined, Undefined, Undefined # type: (A[B], A[B], A[C])
c = b # Fail
b = c # Fail

b = b
b = bb

class A(Generic[T]): pass
class B: pass
class C(B): pass
[out]
main, line 4: Incompatible types in assignment
main, line 5: Incompatible types in assignment

[case testGenericTypeCompatibilityWithAny]
from typing import Undefined, Any, typevar, Generic
T = typevar('T')
b, c, d = Undefined, Undefined, Undefined # type: (A[B], A[C], A[Any])

b = d
c = d
d = b
d = c

class A(Generic[T]): pass
class B: pass
class C(B): pass
[out]

[case testTypeVariableAsTypeArgument]
from typing import Undefined, typevar, Generic
T = typevar('T')
a = Undefined # type: A[B]
b = Undefined # type: A[B]
c = Undefined # type: A[C]

a.v = c # Fail
c = a.v # Fail
a.v = b
b = a.v

class A(Generic[T]):
    v = None # type: A[T]

class B: pass
class C: pass
[out]
main, line 7: Incompatible types in assignment
main, line 8: Incompatible types in assignment

[case testMultipleGenericTypeParametersWithMemberVars]
from typing import Undefined, typevar, Generic
S = typevar('S')
T = typevar('T')
a = Undefined # type: A[B, C]
s = Undefined # type: B
t = Undefined # type: C

t = a.s # Fail
s = a.t # Fail

s = a.s
t = a.t

class A(Generic[S, T]):
    s = Undefined # type: S
    t = Undefined # type: T
class B: pass
class C: pass
[out]
main, line 8: Incompatible types in assignment
main, line 9: Incompatible types in assignment

[case testMultipleGenericTypeParametersWithMethods]
from typing import Undefined, typevar, Generic
S = typevar('S')
T = typevar('T')
a = Undefined # type: A[B, C]
s = Undefined # type: B
t = Undefined # type: C

a.f(s, s) # Fail
a.f(t, t) # Fail
a.f(s, t)

class A(Generic[S, T]):
    def f(self, s: S, t: T) -> None: pass
class B: pass
class C: pass
[out]
main, line 8: Argument 2 to "f" of "A" has incompatible type "B"
main, line 9: Argument 1 to "f" of "A" has incompatible type "C"

[case testMultipleGenericTypeParametersAndSubtyping]
from typing import Undefined, typevar, Generic
S = typevar('S')
T = typevar('T')
bc = Undefined # type: A[B, C]
bb = Undefined # type: A[B, B]
cb = Undefined # type: A[C, B]

bb = bc # Fail
bb = cb # Fail
bc = bb # Fail

bb = bb
bc = bc

class A(Generic[S, T]):
    s = Undefined # type: S
    t = Undefined # type: T

class B: pass
class C(B):pass
[out]
main, line 8: Incompatible types in assignment
main, line 9: Incompatible types in assignment
main, line 10: Incompatible types in assignment


-- Simple generic type bodies
-- --------------------------


[case testGenericTypeBody1]
from typing import typevar, Generic, Undefined
T = typevar('T')
class A(Generic[T]):
    a = Undefined # type: T
    
    def f(self, b: T) -> T:
        self.f(x)     # Fail
        d = self # type: A[B] # Fail
        self.a = self.f(self.a)
        return self.a
        c = self # type: A[T]
x = Undefined # type: B
class B: pass
[out]
main: In member "f" of class "A":
main, line 7: Argument 1 to "f" of "A" has incompatible type "B"
main, line 8: Incompatible types in assignment

[case testGenericTypeBodyWithMultipleVariables]
from typing import typevar, Generic, Undefined
S = typevar('S')
T = typevar('T')
class A(Generic[S, T]):
    def f(self) -> None:
        s = Undefined # type: S
        t = Undefined # type: T
        s = t # Fail
        t = s # Fail
        a = self # type: A[S, B] # Fail
        b = self # type: A[T, T] # Fail
        c = self # type: A[S, T]
        t = t

class B: pass
[out]
main: In member "f" of class "A":
main, line 8: Incompatible types in assignment
main, line 9: Incompatible types in assignment
main, line 10: Incompatible types in assignment
main, line 11: Incompatible types in assignment

[case testCompatibilityOfNoneWithTypeVar]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]):
    def f(self) -> None:
        a = None # type: T
        a = None
[out]

[case testCompatibilityOfTypeVarWithObject]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]):
    def f(self) -> T:
        a = object() # type: T  # Fail
        a = object()    # Fail
        b = self.f() # type: object
        b = self.f()
[out]
main: In member "f" of class "A":
main, line 5: Incompatible types in assignment
main, line 6: Incompatible types in assignment


-- Operations with generic types
-- -----------------------------


[case testGenericOperations]
from typing import Undefined, typevar, Generic
S = typevar('S')
T = typevar('T')
a = Undefined # type: A[B, C]
b = Undefined # type: B
c = Undefined # type: C

b = a + b # Fail
c = a + c # Fail
c = a[c]  # Fail
b = a[b]  # Fail

c = a + b
b = a[c]

class A(Generic[S, T]):
    def __add__(self, a: S) -> T: pass    
    def __getitem__(self, i: T) -> S: pass

class B: pass
class C: pass
[out]
main, line 8: Incompatible types in assignment
main, line 9: Unsupported operand types for + ("A" and "C")
main, line 10: Incompatible types in assignment
main, line 11: Invalid index type "B" for "A"

[case testOperatorAssignmentWithIndexLvalue1]
from typing import Undefined, typevar, Generic
T = typevar('T')
b = Undefined # type: B
c = Undefined # type: C
ac = Undefined # type: A[C]

ac[b] += b # Fail
ac[c] += c # Fail
ac[b] += c
ac[b] = ac[b] + c

class A(Generic[T]):
    def __getitem__(self, i: 'B') -> T: pass    
    def __setitem__(self, i: 'B', v: T) -> None: pass

class B: pass
class C:
    def __add__(self, o: 'C') -> 'C': pass
[out]
main, line 7: Unsupported operand types for + ("C" and "B")
main, line 7: Incompatible types in assignment
main, line 8: Invalid index type "C" for "A"

[case testOperatorAssignmentWithIndexLvalue2]
from typing import Undefined, typevar, Generic
T = typevar('T')
b = Undefined # type: B
c = Undefined # type: C
ac = Undefined # type: A[C]

ac[b] += c        # Fail
ac[c] += c        # Fail
ac[b] = ac[b] + c # Fail

class A(Generic[T]):
    def __getitem__(self, i: 'B') -> T: pass    
    def __setitem__(self, i: 'C', v: T) -> None: pass

class B: pass
class C:
    def __add__(self, o: 'C') -> 'C': pass
[out]
main, line 7: Invalid index type "B" for "A"
main, line 8: Invalid index type "C" for "A"
main, line 9: Invalid index type "B" for "A"


-- Nested generic types
-- --------------------


[case testNestedGenericTypes]
from typing import Undefined, typevar, Generic
T = typevar('T')
aab = Undefined # type: A[A[B]]
aac = Undefined # type: A[A[C]]
ab = Undefined # type: A[B]
ac = Undefined # type: A[C]

ac = aab.x # Fail
ac.y = aab # Fail

ab = aab.x
ac = aac.x
ab.y = aab
ac.y = aac

class A(Generic[T]):
    x = None # type: T
    y = None # type: A[A[T]]

class B:
    pass
class C:
    pass
[out]
main, line 8: Incompatible types in assignment
main, line 9: Incompatible types in assignment


-- Generic functions
-- -----------------


[case testTrivialTypeApplication]
from typing import typevar
T = typevar('T')
def f(x: T) -> None: pass
f[object](None)
[out]

[case testSimpleGenericFunction]
from typing import Undefined, typevar
T = typevar('T')
class A: pass
class B: pass
a = Undefined # type: A
b = Undefined # type: B

def id(a: T) -> T:
    return a

b = id[B](a)  # E: Argument 1 to "id" has incompatible type "A"
a = id[B](b)  # E: Incompatible types in assignment
a = id[A](a)

[case testGenericFunctionWithTwoTypeArguments]
from typing import Undefined, typevar, Generic
S = typevar('S')
T = typevar('T')

class t(Generic[S, T]): pass
class B: pass
class C: pass

tbc = Undefined # type: t[B, C]
tbb = Undefined # type: t[B, B]
b = Undefined # type: B
c = Undefined # type: C

def f(a: S, b: t[S, T]) -> t[S, T]: pass

tbc = f[B, C](c, tbc) # E: Argument 1 to "f" has incompatible type "C"
tbc = f[B, C](b, tbb) # E: Argument 2 to "f" has incompatible type t<B, B>
tbb = f[B, C](b, tbc) # E: Incompatible types in assignment
tbc = f[B, C](b, tbc)

[case testInvalidNumberOfTypeArgumentsForGenericFunction]
from typing import Undefined, typevar, Generic
s = typevar('s')
t = typevar('t')
class p(Generic[s, t]): pass
def f(a: p[s, t]) -> None: pass
def g() -> None: pass
a = Undefined # type: p[object, object]

a = f[object](a) # E: Type application has too few types (2 expected)
a = f[object, object, object](a) # E: Type application has too many types (2 expected)
g[object]() # E: Type application targets a non-generic function
f[object, object](a)

[case testGenericMethodInNonGenericType-skip]
from typing import Undefined, typevar
T = typevar('T')
a, b = Undefined, Undefined # type: (A, B)

a = a.f['B'](b) # Fail
a = a.f['A'](b) # Fail

a = a.f['A'](a)

class A:
    def f(self, a: T) -> T: pass
class B: pass
[out]
main, line 5: Incompatible types in assignment
main, line 6: Argument 1 to "f" of "A" has incompatible type "B"

[case testGenericMethodInGenericType-skip]
from typing import Undefined, typevar, Generic
T = typevar('T')
S = typevar('S')
class A(Generic[T]):
    def f(self, a: S) -> 'A[t[S, T]]':
        pass
class t(Generic[T, S]): pass
class B: pass
class C: pass
ab = Undefined # type: A[B]
acb = Undefined # type: A[t[C, B]]
abc = Undefined # type: A[t[B, C]]
b = Undefined # type: B
c = Undefined # type: C

abc = ab.f[C](c) # E: Incompatible types in assignment
acb = ab.f[C](b) # E: Argument 1 to "f" of "A" has incompatible type "B"
acb = ab.f[C](c)

[case testTypeCheckingGenericFunctionBody]
from typing import typevar, Generic
S = typevar('S')
T = typevar('T')
class A: pass
class p(Generic[T, S]):
    def __init__(self, t: T, a: S) -> None: pass
def f(s: S, t: T) -> p[T, A]:
    a = t # type: S # E: Incompatible types in assignment
    s = t           # E: Incompatible types in assignment
    return p[S, A](s, A()) # E: Incompatible return value type
    b = t # type: T
    c = s # type: S
    return p[T, A](t, A())
[out]
main: In function "f":

[case testTypeCheckingGenericMethodBody]
from typing import typevar, Generic
T = typevar('T')
S = typevar('S')
class p(Generic[T, S]):
    def __init__(self, t: T, a: S) -> None: pass
class A(Generic[T]):
    def f(self, s: S, t: T) -> p[S, T]:
        s = t # E: Incompatible types in assignment
        return p[S, S](s, s) # E: Incompatible return value type
        return p[T, T](t, t) # E: Incompatible return value type
        t = t
        s = s
        return p[S, T](s, t)
[out]
main: In member "f" of class "A":


-- Constructing instances + generics
-- ---------------------------------


[case testConstructingGenericInstanceWithEmptyConstructor]
from typing import typevar, Generic
T = typevar('T')
class A(Generic[T]): pass
class B: pass
class C: pass
a = A[B]() # type: A[C] # Fail
a = A[B]()              # Fail
e = A[B]() # type: A[B]
e = A[B]()
[out]
main, line 6: Incompatible types in assignment
main, line 7: Incompatible types in assignment

[case testNonEmptyGenericTypeConstructor]
from typing import Undefined, typevar, Generic
T = typevar('T')
class B: pass
class C: pass
class A(Generic[T]):
    def __init__(self, a: T, b: B) -> None: pass
ac = Undefined # type: A[C]
ab = Undefined # type: A[B]
b = Undefined # type: B
c = Undefined # type: C

ac = A[C](b, b) # E: Argument 1 to "A" has incompatible type "B"
ab = A[C](c, b) # E: Incompatible types in assignment
ac = A[C](c, b)

[case testConstructorForGenericTypeWithMultipleArguments]
from typing import Undefined, typevar, Generic
S = typevar('S')
T = typevar('T')
class A(Generic[S, T]):
    def __init__(self, t: T, s: S) -> None: pass
class B: pass
class C: pass

abc = Undefined # type: A[B, C]
acb = Undefined # type: A[C, B]
b, c = Undefined, Undefined # type: (B, C)

abc = A[B, C](b, b) # E: Argument 1 to "A" has incompatible type "B"
abc = A[B, C](c, c) # E: Argument 2 to "A" has incompatible type "C"
acb = A[B, C](c, b) # E: Incompatible types in assignment
abc = A[B, C](c, b)
acb = A[C, B](b, c)

[case testGenericConstructorOfNonGenericType]
from typing import Undefined, typevar
T = typevar('T')
class A:
    def __init__(self, a: T, b: T) -> None: pass
class B: pass
class C: pass
a, b, c = Undefined, Undefined, Undefined # type: (A, B, C)

a = A[B](b, c) # E: Argument 2 to "A" has incompatible type "C"
a = A[B](c, b) # E: Argument 1 to "A" has incompatible type "C"
b = A[B](b, b) # E: Incompatible types in assignment

a = A[B](b, b)
a = A[C](c, c)

[case testInvalidTypeApplicationTarget]
from typing import Undefined
a = Undefined # type: A
class A: pass
a[A]() # Fail
A[A]() # Fail
[out]
main, line 4: Value of type "A" is not indexable
main, line 5: Type application targets a non-generic function


-- Multiple assignment with lists
-- ------------------------------


[case testMultipleAsssignmentWithLists]
from typing import Undefined, List
class A: pass
class B: pass
class B2(B): pass
a = Undefined # type: A
b = Undefined # type: B
b2 = Undefined # type: B2

a, b = List[A]()   # E: Incompatible types in assignment
b, a = List[A]()   # E: Incompatible types in assignment
b2, b2 = List[B]() # E: Incompatible types in assignment

a, a = List[A]()
b, b2, b = List[B2]()
[builtins fixtures/list.py]

[case testMultipleAssignmentWithListsInInitialization]
from typing import List
class A: pass
a, b = List[object]() # type: (A, object) # E: Incompatible types in assignment
c, d = List[object]() # type: (object, A) # E: Incompatible types in assignment
e, f = List[A]() # type: (A, object)
[builtins fixtures/list.py]

[case testMultipleAssignmentWithListAndIndexing]
from typing import Undefined, List
a = Undefined # type: List[A]
b = Undefined # type: List[int]

a[1], b[1] = a # E: Incompatible types in assignment
a[1], a[2] = a

class A: pass
[file builtins.py]
from typing import typevar, Generic
T = typevar('T')
class object: pass
class list(Generic[T]):
  def __setitem__(self, x: int, v: T) -> None: pass
class int: pass
class type: pass


-- Error messages
-- --------------


[case testErrorWithLongGenericTypeName]
from typing import Undefined, typevar, Generic
B = typevar('B')
C = typevar('C')
D = typevar('D')
E = typevar('E')
F = typevar('F')
G = typevar('G')
class O: pass
a = Undefined # type: A[object, object, object, object, object, object]

f(a) # E: Argument 1 to "f" has incompatible type A<...>

def f(a: O) -> None:
    pass
class A(Generic[B, C, D, E, F, G]): pass

[case testErrorWithShorterGenericTypeName]
from typing import Undefined, typevar, Generic
S = typevar('S')
T = typevar('T')
a = Undefined # type: A[object, B]
f(a) # E: Argument 1 to "f" has incompatible type A<object, B>

def f(a: 'B') -> None: pass
class A(Generic[S, T]): pass
class B: pass

[case testErrorWithShorterGenericTypeName2]
from typing import Undefined, Function, typevar, Generic
S = typevar('S')
T = typevar('T')
a = Undefined # type: A[object, Function[[], None]]
f(a) # E: Argument 1 to "f" has incompatible type A<object, function>

def f(a: 'B') -> None: pass
class A(Generic[S, T]): pass
class B: pass


-- Overloads + generics
-- --------------------


[case testGenericArgumentInOverload]
from typing import Undefined, overload, List
class A: pass
class B: pass
a, b = Undefined, Undefined # type: (A, B)

@overload
def f(a: List[A]) -> A: pass
@overload
def f(a: B) -> B: pass

b = f([a]) # E: Incompatible types in assignment
a = f([b]) # E: List item 1 has incompatible type "B"
a = f(b)   # E: Incompatible types in assignment

a = f([a])
b = f(b)
[builtins fixtures/list.py]

[case testGenericFunctionAsOverloadItem-skip]
from typing import Undefined, overload, typevar, List
T = typevar('T')
a, b = Undefined, Undefined # type: (A, B)

b = f([a]) # E: List item 1 has incompatible type "A"
a = f([b]) # E: List item 1 has incompatible type "B"
a = f(b)   # E: Incompatible types in assignment

a = f([a])
b = f([b])
b = f(b)

@overload
def f(a: 'B') -> 'B': pass
@overload
def f(a: List[T]) -> T: pass

class A: pass
class B: pass
[builtins fixtures/list.py]

[case testOverloadedGenericFunction-skip]
from typing import overload, typevar, Undefined
t = typevar('t')
@overload
def f(a: 'A') -> 'A': pass
@overload
def f(a: t) -> t: pass
a, b = Undefined, Undefined # type: (A, B)
b = f['B'](b)
a = f['B'](b) # E: Incompatible types in assignment
f['B'](a) # E: No overload variant of "f" matches argument types

class A: pass
class B: pass


-- For statements (without type inference)
-- ---------------------------------------


[case testSimpleForStatement-skip]
from typing import Undefined, List, Iterator

class A: pass
class B:
    def __iter__(self) -> Iterator[A]: pass
    
ab = Undefined # type: List[B]
a = Undefined # type: A
b = Undefined # type: B

for x: B in ab:
    a = x # E: Incompatible types in assignment
    b = x

for y: A in ab:  # E: Incompatible types in for statement
    b = y # E: Incompatible types in assignment
    a = y

for z: A in B(): # E: Iterable expected
    pass
[builtins fixtures/for.py]

[case testForStatementWithMultipleVars1-skip]
from typing import Undefined, Tuple, List
at = Undefined # type: List[Tuple[A, B]]
aab = Undefined # type: List[List[B]]
a, b = Undefined, Undefined # type: (A, B)

class A: pass
class B: pass

for x: A, y: B in at:
    b = x # E: Incompatible types in assignment
    a = y # E: Incompatible types in assignment
    a = x
    b = y

for e: B, f: B in aab:
    a = e # E: Incompatible types in assignment
    a = f # E: Incompatible types in assignment
    b = e
    b = f
[builtins fixtures/for.py]

[case testForStatementWithMultipleVars2-skip]
from typing import Undefined, Tuple, List

class A: pass
class B: pass

at = Undefined # type: List[Tuple[A, B]]
aab = Undefined # type: List[List[B]]
aa = Undefined # type: List[A]

a, b = Undefined, Undefined # type: (A, B)

for x1: A, y1: A in at: pass  # E: Incompatible types in for statement
for x2: B, y2: B in at: pass  # E: Incompatible types in for statement
for x3: B, y3: A in aab: pass # E: Incompatible types in for statement
for x4: A, y4: B in aab: pass # E: Incompatible types in for statement
for x5: A, y5: A in aa: pass  # E: Incompatible types in for statement
[builtins fixtures/for.py]

[case testForStatementWithVoid-skip]
import typing
for x: object in f(): pass # E: "f" does not return a value
def f() -> None: pass
[builtins fixtures/for.py]

[case testReusingForIndexVariable-skip]
import typing
class A: pass
class B: pass
for a: A in []: pass
a = A()
a = B() # E: Incompatible types in assignment
for a in []: pass
a = A()
a = B() # E: Incompatible types in assignment
[builtins fixtures/for.py]

[case testReusingForIndexVariable2-skip]
import typing
class A: pass
class B: pass
def f() -> None:
    for a: A in []: pass
    a = A()
    a = B() # E: Incompatible types in assignment
    for a in []: pass
    a = A()
    a = B() # E: Incompatible types in assignment
[builtins fixtures/for.py]
[out]
main: In function "f":
